{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 53199fd1ca90a52780b7","webpack:///../~/inferno/inferno.js","webpack:///../~/inferno-create-element/inferno-create-element.js","webpack:///./acomponent.js","webpack:///../~/inferno/dist/inferno-create-element.node.js","webpack:///../~/inferno/dist/inferno.node.js","webpack:///./myapp.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","default","MyComponent","props","__WEBPACK_IMPORTED_MODULE_1_inferno_create_element___default","message","__WEBPACK_IMPORTED_MODULE_0_inferno__","__WEBPACK_IMPORTED_MODULE_1_inferno_create_element__","global","factory","this","inferno","isStatefulComponent","isUndefined","render","isInvalid","obj","isNull","isTrue","isAttrAnEvent","attr","length","isString","undefined","isObject","createElement$1","_children","len","arguments","Error","children","ref","key","events","flags","prop","prop$1","componentHooks","createVNode","onComponentWillMount","onComponentDidMount","onComponentWillUnmount","onComponentShouldUpdate","onComponentWillUpdate","onComponentDidUpdate","isStringOrNumber","type","isNullOrUndef","isFunction","isNumber","throwError","ERROR_MSG","applyKey","vNode","applyKeyIfMissing","applyKeyPrefix","_normalizeVNodes","nodes","result","index","currentKey","isArray","createTextVNode","isVNode","dom","cloneVNode","push","normalizeVNodes","newNodes","slice","normalizeChildren","normalizeProps","copyPropsTo","copyFrom","copyTo","normalizeElement","normalize","hasProps","noNormalise","options","vNodeToClone","concat","newVNode","tmpArray","assign","newProps","newChildren","i$1","child","createVoidVNode","text","constructDefaults","string","split","forEach","kebabize","str","smallLetter","largeLetter","toLowerCase","handleEvent","lastEvent","nextEvent","delegatedRoots","delegatedEvents","items","Map","count","docEvent","attachEventToDocument","set","isiOS","trapClickOnNonInteractiveElement","has","delete","document","removeEventListener","normalizeEventName","dispatchEvent","event","eventData","eventsToTrigger","data","stopPropagation","parentDom","parentNode","body","substr","target","addEventListener","emptyFn","onclick","isCheckedType","isControlled","usesChecked","checked","onTextInputChange","e","EMPTY_OBJ","onInput","oninput","applyValue","wrappedOnChange","onChange","onCheckboxChange","onClick","handleAssociatedRadioInputs","inputs","querySelectorAll","inputWrapper","wrappers","processInput","bind","wrapped","onchange","multiple","isControlled$1","updateChildOptionGroup","updateChildOption","indexOf","selected","onSelectChange","applyValue$1","processSelect","selectWrapper","isControlled$2","wrappedOnChange$1","onTextareaInputChange","applyValue$2","processTextarea","textareaWrapper","processElement","unmount","lifecycle","canRecycle","isRecycling","unmountComponent","unmountElement","unmountVoidOrText","removeChild","instance","isStatefulComponent$$1","alreadyUnmounted","_unmounted","_ignoreSetState","beforeUnmount","componentWillUnmount","findDOMNodeEnabled","componentToDOMNodeMap","subLifecycle","_lifecycle","fastUnmount","_lastInput","lastInput","recyclingEnabled","poolComponent","unmountRef","unmountChildren$1","patchEvent","poolElement","patch","lastVNode","nextVNode","context","isSVG","lastFlags","nextFlags","patchComponent","replaceVNode","mountComponent","patchElement","mountElement","patchText","mountText","patchVoid","mountVoid","replaceLastChildAndUnmount","unmountChildren","removeAllChildren","textContent","nextTag","lastTag","replaceWithNewNode","lastProps","nextProps","lastChildren","nextChildren","lastRef","nextRef","lastEvents","nextEvents","patchChildren","patchProps","patchEvents","mountRef","patchArray","patchKeyed","setTextContent","mountArrayChildren","mount","updateTextContent","isKeyed","patchKeyedChildren","patchNonKeyedChildren","isClass","lastType","nextType","lastKey","nextKey","defaultProps","nextInput","createFunctionalComponentInput","mountFunctionalComponentCallbacks","replaceChild","lastState","state","nextState","childContext","getChildContext","_isSVG","lastInput$1","nextInput$1","_updateComponent","didUpdate","_childContext","NO_OP","parentVNode","_vNode","componentDidUpdate","afterUpdate","shouldUpdate","lastProps$1","nextHooks","nextHooksDefined","lastInput$2","nextInput$2","nextText","nodeValue","lastChildrenLength","nextChildrenLength","commonLength","nextChild","nextChild$1","appendChild","a","b","j","aNode","bNode","nextNode","nextPos","node","aLength","bLength","aEnd","bEnd","aStart","bStart","aStartNode","bStartNode","aEndNode","bEndNode","outer","insertOrAppend","aNullable","sources","Array","moved","pos","patched","keyIndex","seq","lis_algorithm","u","v","patchProp","lastValue","nextValue","skipProps","booleanProps","strictProps","removeAttribute","setAttribute","className","patchStyle","lastHtml","__html","nextHtml","innerHTML","dehyphenProp","dehyphenProps","match","probablyKebabProps","replace","ns","namespaces","setAttributeNS","name$1","nameLowerCase","domEvent","delegatedProps","linkEvent","_data","currentTarget","removeProp","lastAttrValue","nextAttrValue","style","cssText","isUnitlessNumber","style$1","recycleElement","tag","pools","elementPools","pool","nonKeyed","keyed","recycledVNode","pop","recycleComponent","componentPools","failed","hooks","nonRecycleHooks","createTextNode","dom$1","documentCreateElement","createClassComponentInstance","input","prevFastUnmount","Lifecycle","mountClassComponentCallbacks","input$1","cDM","componentDidMount","afterMount","addListener","Component","_patch","_componentToDOMNodeMap","_pendingSetState","componentWillMount","beforeRender","afterRender","shallowUnmount","component","firstChild","newNode","insertBefore","createElementNS","svgNS","createElement","lastNode","nextDom","lastDom","removeChildren","normalizeChildNodes","nodeType","placeholder","nextSibling","previousSibling","hydrateComponent","namespaceURI","_vComponent","hydrate","hydrateElement","tagName","newDom","hydrateChildren","hydrateText","hydrateVoid","hydrateRoot","findDOMNode","getRoot","roots","root","setRoot","removeRoot","splice","documentBody","trigger","lifecycle$1","listeners","rootInput","createRenderer","_parentDom","isBrowser","window","callback","this$1","xlinkNS","xmlNS","httpEquiv","acceptCharset","navigator","platform","test","WeakMap","runapp","__WEBPACK_IMPORTED_MODULE_0_inferno___default","__WEBPACK_IMPORTED_MODULE_2__acomponent__","getElementById","readyState","console","info"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(4);\nmodule.exports.default = module.exports;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(3);\nmodule.exports.default = module.exports;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inferno__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inferno___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_inferno__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_inferno_create_element__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_inferno_create_element___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_inferno_create_element__);\n\n\n\nvar message = 'subcomponent';\n\nfunction MyComponent(props) {\n  return __WEBPACK_IMPORTED_MODULE_1_inferno_create_element___default()('div', null, message);\n}\n\n/* harmony default export */ exports[\"a\"] = MyComponent;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n/*!\n * inferno-create-element v1.1.1\n * (c) 2017 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n     true ? module.exports = factory(__webpack_require__(0)) :\n    typeof define === 'function' && define.amd ? define(['inferno'], factory) :\n    (global.Inferno = global.Inferno || {}, global.Inferno.createElement = factory(global.Inferno));\n}(this, (function (inferno) { 'use strict';\n\n// this is MUCH faster than .constructor === Array and instanceof Array\n// in Node 7 and the later versions of V8, slower in older versions though\n\nfunction isStatefulComponent(o) {\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\n}\n\n\nfunction isInvalid(obj) {\n    return isNull(obj) || obj === false || isTrue(obj) || isUndefined(obj);\n}\n\nfunction isAttrAnEvent(attr) {\n    return attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n}\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\n\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isObject(o) {\n    return typeof o === 'object';\n}\n\nvar componentHooks = {\n    onComponentWillMount: true,\n    onComponentDidMount: true,\n    onComponentWillUnmount: true,\n    onComponentShouldUpdate: true,\n    onComponentWillUpdate: true,\n    onComponentDidUpdate: true\n};\nfunction createElement$1(name, props) {\n    var _children = [], len = arguments.length - 2;\n    while ( len-- > 0 ) _children[ len ] = arguments[ len + 2 ];\n\n    if (isInvalid(name) || isObject(name)) {\n        throw new Error('Inferno Error: createElement() name parameter cannot be undefined, null, false or true, It must be a string, class or function.');\n    }\n    var children = _children;\n    var ref = null;\n    var key = null;\n    var events = null;\n    var flags = 0;\n    if (_children) {\n        if (_children.length === 1) {\n            children = _children[0];\n        }\n        else if (_children.length === 0) {\n            children = undefined;\n        }\n    }\n    if (isString(name)) {\n        flags = 2 /* HtmlElement */;\n        switch (name) {\n            case 'svg':\n                flags = 128 /* SvgElement */;\n                break;\n            case 'input':\n                flags = 512 /* InputElement */;\n                break;\n            case 'textarea':\n                flags = 1024 /* TextareaElement */;\n                break;\n            case 'select':\n                flags = 2048 /* SelectElement */;\n                break;\n            default:\n        }\n        for (var prop in props) {\n            if (prop === 'key') {\n                key = props.key;\n                delete props.key;\n            }\n            else if (prop === 'children' && isUndefined(children)) {\n                children = props.children; // always favour children args, default to props\n            }\n            else if (prop === 'ref') {\n                ref = props.ref;\n            }\n            else if (isAttrAnEvent(prop)) {\n                if (!events) {\n                    events = {};\n                }\n                events[prop] = props[prop];\n                delete props[prop];\n            }\n        }\n    }\n    else {\n        flags = isStatefulComponent(name) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;\n        if (!isUndefined(children)) {\n            if (!props) {\n                props = {};\n            }\n            props.children = children;\n            children = null;\n        }\n        for (var prop$1 in props) {\n            if (componentHooks[prop$1]) {\n                if (!ref) {\n                    ref = {};\n                }\n                ref[prop$1] = props[prop$1];\n            }\n            else if (prop$1 === 'key') {\n                key = props.key;\n                delete props.key;\n            }\n        }\n    }\n    return inferno.createVNode(flags, name, props, children, events, key, ref);\n}\n\nreturn createElement$1;\n\n})));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n/*!\n * inferno v1.1.1\n * (c) 2017 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Inferno = global.Inferno || {})));\n}(this, (function (exports) { 'use strict';\n\nvar NO_OP = '$NO_OP';\nvar ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\nvar isBrowser = typeof window !== 'undefined' && window.document;\n\n// this is MUCH faster than .constructor === Array and instanceof Array\n// in Node 7 and the later versions of V8, slower in older versions though\nvar isArray = Array.isArray;\nfunction isStatefulComponent(o) {\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\n}\nfunction isStringOrNumber(obj) {\n    var type = typeof obj;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(obj) {\n    return isUndefined(obj) || isNull(obj);\n}\nfunction isInvalid(obj) {\n    return isNull(obj) || obj === false || isTrue(obj) || isUndefined(obj);\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nfunction isAttrAnEvent(attr) {\n    return attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n}\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\nfunction isNumber(obj) {\n    return typeof obj === 'number';\n}\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isObject(o) {\n    return typeof o === 'object';\n}\nfunction throwError(message) {\n    if (!message) {\n        message = ERROR_MSG;\n    }\n    throw new Error((\"Inferno Error: \" + message));\n}\nfunction warning(condition, message) {\n    if (!condition) {\n        console.error(message);\n    }\n}\nvar EMPTY_OBJ = {};\n\nfunction applyKey(key, vNode) {\n    vNode.key = key;\n    return vNode;\n}\nfunction applyKeyIfMissing(key, vNode) {\n    if (isNumber(key)) {\n        key = \".\" + key;\n    }\n    if (isNull(vNode.key) || vNode.key[0] === '.') {\n        return applyKey(key, vNode);\n    }\n    return vNode;\n}\nfunction applyKeyPrefix(key, vNode) {\n    vNode.key = key + vNode.key;\n    return vNode;\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (; index < nodes.length; index++) {\n        var n = nodes[index];\n        var key = currentKey + \".\" + index;\n        if (!isInvalid(n)) {\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, key);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n);\n                }\n                else if (isVNode(n) && n.dom || (n.key && n.key[0] === '.')) {\n                    n = cloneVNode(n);\n                }\n                if (isNull(n.key) || n.key[0] === '.') {\n                    n = applyKey(key, n);\n                }\n                else {\n                    n = applyKeyPrefix(currentKey, n);\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction normalizeVNodes(nodes) {\n    var newNodes;\n    // we assign $ which basically means we've flagged this array for future note\n    // if it comes back again, we need to clone it, as people are using it\n    // in an immutable way\n    // tslint:disable\n    if (nodes['$']) {\n        nodes = nodes.slice();\n    }\n    else {\n        nodes['$'] = true;\n    }\n    // tslint:enable\n    for (var i = 0; i < nodes.length; i++) {\n        var n = nodes[i];\n        if (isInvalid(n) || isArray(n)) {\n            var result = (newNodes || nodes).slice(0, i);\n            _normalizeVNodes(nodes, result, i, \"\");\n            return result;\n        }\n        else if (isStringOrNumber(n)) {\n            if (!newNodes) {\n                newNodes = nodes.slice(0, i);\n            }\n            newNodes.push(applyKeyIfMissing(i, createTextVNode(n)));\n        }\n        else if ((isVNode(n) && n.dom) || (isNull(n.key) && !(n.flags & 64 /* HasNonKeyedChildren */))) {\n            if (!newNodes) {\n                newNodes = nodes.slice(0, i);\n            }\n            newNodes.push(applyKeyIfMissing(i, cloneVNode(n)));\n        }\n        else if (newNodes) {\n            newNodes.push(applyKeyIfMissing(i, cloneVNode(n)));\n        }\n    }\n    return newNodes || nodes;\n}\nfunction normalizeChildren(children) {\n    if (isArray(children)) {\n        return normalizeVNodes(children);\n    }\n    else if (isVNode(children) && children.dom) {\n        return cloneVNode(children);\n    }\n    return children;\n}\nfunction normalizeProps(vNode, props, children) {\n    if (!(vNode.flags & 28 /* Component */) && isNullOrUndef(children) && !isNullOrUndef(props.children)) {\n        vNode.children = props.children;\n    }\n    if (props.ref) {\n        vNode.ref = props.ref;\n        delete props.ref;\n    }\n    if (props.events) {\n        vNode.events = props.events;\n    }\n    if (!isNullOrUndef(props.key)) {\n        vNode.key = props.key;\n        delete props.key;\n    }\n}\nfunction copyPropsTo(copyFrom, copyTo) {\n    for (var prop in copyFrom) {\n        if (isUndefined(copyTo[prop])) {\n            copyTo[prop] = copyFrom[prop];\n        }\n    }\n}\nfunction normalizeElement(type, vNode) {\n    if (type === 'svg') {\n        vNode.flags = 128 /* SvgElement */;\n    }\n    else if (type === 'input') {\n        vNode.flags = 512 /* InputElement */;\n    }\n    else if (type === 'select') {\n        vNode.flags = 2048 /* SelectElement */;\n    }\n    else if (type === 'textarea') {\n        vNode.flags = 1024 /* TextareaElement */;\n    }\n    else if (type === 'media') {\n        vNode.flags = 256 /* MediaElement */;\n    }\n    else {\n        vNode.flags = 2 /* HtmlElement */;\n    }\n}\nfunction normalize(vNode) {\n    var props = vNode.props;\n    var hasProps = !isNull(props);\n    var type = vNode.type;\n    var children = vNode.children;\n    // convert a wrongly created type back to element\n    if (isString(type) && (vNode.flags & 28 /* Component */)) {\n        normalizeElement(type, vNode);\n        if (hasProps && props.children) {\n            vNode.children = props.children;\n            children = props.children;\n        }\n    }\n    if (hasProps) {\n        normalizeProps(vNode, props, children);\n    }\n    if (!isInvalid(children)) {\n        vNode.children = normalizeChildren(children);\n    }\n    if (hasProps && !isInvalid(props.children)) {\n        props.children = normalizeChildren(props.children);\n    }\n    if (false) {\n        // This code will be stripped out from production CODE\n        // It will help users to track errors in their applications.\n        function verifyKeys(vNodes) {\n            var keyValues = vNodes.map(function (vnode) { return vnode.key; });\n            keyValues.some(function (item, idx) {\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\n                warning(!hasDuplicate, 'Infreno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:' + item);\n                return hasDuplicate;\n            });\n        }\n        if (vNode.children && Array.isArray(vNode.children)) {\n            verifyKeys(vNode.children);\n        }\n    }\n}\n\nvar options = {\n    recyclingEnabled: true,\n    findDOMNodeEnabled: false,\n    roots: null,\n    createVNode: null,\n    beforeRender: null,\n    afterRender: null,\n    afterMount: null,\n    afterUpdate: null,\n    beforeUnmount: null\n};\n\nfunction createVNode(flags, type, props, children, events, key, ref, noNormalise) {\n    if (flags & 16 /* ComponentUnknown */) {\n        flags = isStatefulComponent(type) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;\n    }\n    var vNode = {\n        children: isUndefined(children) ? null : children,\n        dom: null,\n        events: events || null,\n        flags: flags,\n        key: isUndefined(key) ? null : key,\n        props: props || null,\n        ref: ref || null,\n        type: type\n    };\n    if (!noNormalise) {\n        normalize(vNode);\n    }\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    return vNode;\n}\nfunction cloneVNode(vNodeToClone, props) {\n    var _children = [], len = arguments.length - 2;\n    while ( len-- > 0 ) _children[ len ] = arguments[ len + 2 ];\n\n    var children = _children;\n    if (_children.length > 0 && !isNull(_children[0])) {\n        if (!props) {\n            props = {};\n        }\n        if (_children.length === 1) {\n            children = _children[0];\n        }\n        if (isUndefined(props.children)) {\n            props.children = children;\n        }\n        else {\n            if (isArray(children)) {\n                if (isArray(props.children)) {\n                    props.children = props.children.concat(children);\n                }\n                else {\n                    props.children = [props.children].concat(children);\n                }\n            }\n            else {\n                if (isArray(props.children)) {\n                    props.children.push(children);\n                }\n                else {\n                    props.children = [props.children];\n                    props.children.push(children);\n                }\n            }\n        }\n    }\n    children = null;\n    var newVNode;\n    if (isArray(vNodeToClone)) {\n        var tmpArray = [];\n        for (var i = 0; i < vNodeToClone.length; i++) {\n            tmpArray.push(cloneVNode(vNodeToClone[i]));\n        }\n        newVNode = tmpArray;\n    }\n    else {\n        var flags = vNodeToClone.flags;\n        var events = vNodeToClone.events || (props && props.events) || null;\n        var key = !isNullOrUndef(vNodeToClone.key) ? vNodeToClone.key : (props ? props.key : null);\n        var ref = vNodeToClone.ref || (props ? props.ref : null);\n        if (flags & 28 /* Component */) {\n            newVNode = createVNode(flags, vNodeToClone.type, Object.assign({}, vNodeToClone.props, props), null, events, key, ref, true);\n            var newProps = newVNode.props;\n            if (newProps) {\n                var newChildren = newProps.children;\n                // we need to also clone component children that are in props\n                // as the children may also have been hoisted\n                if (newChildren) {\n                    if (isArray(newChildren)) {\n                        for (var i$1 = 0; i$1 < newChildren.length; i$1++) {\n                            var child = newChildren[i$1];\n                            if (!isInvalid(child) && isVNode(child)) {\n                                newProps.children[i$1] = cloneVNode(child);\n                            }\n                        }\n                    }\n                    else if (isVNode(newChildren)) {\n                        newProps.children = cloneVNode(newChildren);\n                    }\n                }\n            }\n            newVNode.children = null;\n        }\n        else if (flags & 3970 /* Element */) {\n            children = (props && props.children) || vNodeToClone.children;\n            newVNode = createVNode(flags, vNodeToClone.type, Object.assign({}, vNodeToClone.props, props), children, events, key, ref, !children);\n        }\n        else if (flags & 1 /* Text */) {\n            newVNode = createTextVNode(vNodeToClone.children);\n        }\n    }\n    return newVNode;\n}\nfunction createVoidVNode() {\n    return createVNode(4096 /* Void */);\n}\nfunction createTextVNode(text) {\n    return createVNode(1 /* Text */, null, null, text, null, null, null, true);\n}\nfunction isVNode(o) {\n    return !!o.flags;\n}\n\nvar Lifecycle = function Lifecycle() {\n    this.listeners = [];\n    this.fastUnmount = true;\n};\nLifecycle.prototype.addListener = function addListener (callback) {\n    this.listeners.push(callback);\n};\nLifecycle.prototype.trigger = function trigger () {\n        var this$1 = this;\n\n    for (var i = 0; i < this.listeners.length; i++) {\n        this$1.listeners[i]();\n    }\n};\n\nfunction constructDefaults(string, object, value) {\n    /* eslint no-return-assign: 0 */\n    string.split(',').forEach(function (i) { return object[i] = value; });\n}\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar svgNS = 'http://www.w3.org/2000/svg';\nvar strictProps = {};\nvar booleanProps = {};\nvar namespaces = {};\nvar isUnitlessNumber = {};\nvar skipProps = {};\nvar dehyphenProps = {\n    httpEquiv: 'http-equiv',\n    acceptCharset: 'accept-charset'\n};\nvar probablyKebabProps = /^(accentH|arabicF|capH|font[FSVW]|glyph[NO]|horiz[AO]|panose1|renderingI|strikethrough[PT]|underline[PT]|v[AHIM]|vert[AO]|xH|alignmentB|baselineS|clip[PR]|color[IPR]|dominantB|enableB|fill[OR]|flood[COF]|imageR|letterS|lightingC|marker[EMS]|pointerE|shapeR|stop[CO]|stroke[DLMOW]|text[ADR]|unicodeB|wordS|writingM).*/;\nfunction kebabize(str, smallLetter, largeLetter) {\n    return (smallLetter + \"-\" + (largeLetter.toLowerCase()));\n}\nvar delegatedProps = {};\nconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\nconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\nconstructDefaults('volume,defaultValue,defaultChecked', strictProps, true);\nconstructDefaults('children,ref,key,selected,checked,value,multiple', skipProps, true);\nconstructDefaults('onClick,onMouseDown,onMouseUp,onMouseMove,onSubmit,onDblClick,onKeyDown,onKeyUp,onKeyPress', delegatedProps, true);\nconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,readOnly,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\nconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\nvar isiOS = isBrowser && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\nvar delegatedEvents = new Map();\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\n    var delegatedRoots = delegatedEvents.get(name);\n    if (nextEvent) {\n        if (!delegatedRoots) {\n            delegatedRoots = { items: new Map(), count: 0, docEvent: null };\n            var docEvent = attachEventToDocument(name, delegatedRoots);\n            delegatedRoots.docEvent = docEvent;\n            delegatedEvents.set(name, delegatedRoots);\n        }\n        if (!lastEvent) {\n            delegatedRoots.count++;\n            if (isiOS && name === 'onClick') {\n                trapClickOnNonInteractiveElement(dom);\n            }\n        }\n        delegatedRoots.items.set(dom, nextEvent);\n    }\n    else if (delegatedRoots) {\n        if (delegatedRoots.items.has(dom)) {\n            delegatedRoots.count--;\n            delegatedRoots.items.delete(dom);\n            if (delegatedRoots.count === 0) {\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\n                delegatedEvents.delete(name);\n            }\n        }\n    }\n}\nfunction dispatchEvent(event, dom, items, count, eventData) {\n    var eventsToTrigger = items.get(dom);\n    if (eventsToTrigger) {\n        count--;\n        // linkEvent object\n        eventData.dom = dom;\n        if (eventsToTrigger.event) {\n            eventsToTrigger.event(eventsToTrigger.data, event);\n        }\n        else {\n            eventsToTrigger(event);\n        }\n        if (eventData.stopPropagation) {\n            return;\n        }\n    }\n    var parentDom = dom.parentNode;\n    if (count > 0 && (parentDom || parentDom === document.body)) {\n        dispatchEvent(event, parentDom, items, count, eventData);\n    }\n}\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction attachEventToDocument(name, delegatedRoots) {\n    var docEvent = function (event) {\n        var eventData = {\n            stopPropagation: false,\n            dom: document\n        };\n        // we have to do this as some browsers recycle the same Event between calls\n        // so we need to make the property configurable\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            get: function get() {\n                return eventData.dom;\n            }\n        });\n        event.stopPropagation = function () {\n            eventData.stopPropagation = true;\n        };\n        var count = delegatedRoots.count;\n        if (count > 0) {\n            dispatchEvent(event, event.target, delegatedRoots.items, count, eventData);\n        }\n    };\n    document.addEventListener(normalizeEventName(name), docEvent);\n    return docEvent;\n}\nfunction emptyFn() { }\nfunction trapClickOnNonInteractiveElement(dom) {\n    // Mobile Safari does not fire properly bubble click events on\n    // non-interactive elements, which means delegated click listeners do not\n    // fire. The workaround for this bug involves attaching an empty click\n    // listener on the target node.\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n    // Just set it using the onclick property so that we don't have to manage any\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\n    // removed.\n    // TODO: Only do this for the relevant Safaris maybe?\n    dom.onclick = emptyFn;\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nfunction isControlled(props) {\n    var usesChecked = isCheckedType(props.type);\n    return usesChecked ? !isNullOrUndef(props.checked) : !isNullOrUndef(props.value);\n}\nfunction onTextInputChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onInput) {\n        var event = events.onInput;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.oninput) {\n        events.oninput(e);\n    }\n    // the user may have updated the vNode from the above onInput events\n    // so we need to get it from the context of `this` again\n    applyValue(this.vNode, dom);\n}\nfunction wrappedOnChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var event = events.onChange;\n    if (event.event) {\n        event.event(event.data, e);\n    }\n    else {\n        event(e);\n    }\n}\nfunction onCheckboxChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onClick) {\n        var event = events.onClick;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.onclick) {\n        events.onclick(e);\n    }\n    // the user may have updated the vNode from the above onClick events\n    // so we need to get it from the context of `this` again\n    applyValue(this.vNode, dom);\n}\nfunction handleAssociatedRadioInputs(name) {\n    var inputs = document.querySelectorAll((\"input[type=\\\"radio\\\"][name=\\\"\" + name + \"\\\"]\"));\n    [].forEach.call(inputs, function (dom) {\n        var inputWrapper = wrappers.get(dom);\n        if (inputWrapper) {\n            var props = inputWrapper.vNode.props;\n            if (props) {\n                dom.checked = inputWrapper.vNode.props.checked;\n            }\n        }\n    });\n}\nfunction processInput(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue(vNode, dom);\n    if (isControlled(props)) {\n        var inputWrapper = wrappers.get(dom);\n        if (!inputWrapper) {\n            inputWrapper = {\n                vNode: vNode\n            };\n            if (isCheckedType(props.type)) {\n                dom.onclick = onCheckboxChange.bind(inputWrapper);\n                dom.onclick.wrapped = true;\n            }\n            else {\n                dom.oninput = onTextInputChange.bind(inputWrapper);\n                dom.oninput.wrapped = true;\n            }\n            if (props.onChange) {\n                dom.onchange = wrappedOnChange.bind(inputWrapper);\n                dom.onchange.wrapped = true;\n            }\n            wrappers.set(dom, inputWrapper);\n        }\n        inputWrapper.vNode = vNode;\n    }\n}\nfunction applyValue(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    var type = props.type;\n    var value = props.value;\n    var checked = props.checked;\n    var multiple = props.multiple;\n    if (type && type !== dom.type) {\n        dom.type = type;\n    }\n    if (multiple && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (isCheckedType(type)) {\n        if (!isNullOrUndef(value)) {\n            dom.value = value;\n        }\n        dom.checked = checked;\n        if (type === 'radio' && props.name) {\n            handleAssociatedRadioInputs(props.name);\n        }\n    }\n    else {\n        if (!isNullOrUndef(value) && dom.value !== value) {\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction isControlled$1(props) {\n    return !isNullOrUndef(props.value);\n}\nfunction updateChildOptionGroup(vNode, value) {\n    var type = vNode.type;\n    if (type === 'optgroup') {\n        var children = vNode.children;\n        if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n                updateChildOption(children[i], value);\n            }\n        }\n        else if (isVNode(children)) {\n            updateChildOption(children, value);\n        }\n    }\n    else {\n        updateChildOption(vNode, value);\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if ((isArray(value) && value.indexOf(props.value) !== -1) || props.value === value) {\n        dom.selected = true;\n    }\n    else {\n        dom.selected = props.selected || false;\n    }\n}\nfunction onSelectChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onChange) {\n        var event = events.onChange;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.onchange) {\n        events.onchange(e);\n    }\n    // the user may have updated the vNode from the above onChange events\n    // so we need to get it from the context of `this` again\n    applyValue$1(this.vNode, dom);\n}\nfunction processSelect(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue$1(vNode, dom);\n    if (isControlled$1(props)) {\n        var selectWrapper = wrappers.get(dom);\n        if (!selectWrapper) {\n            selectWrapper = {\n                vNode: vNode\n            };\n            dom.onchange = onSelectChange.bind(selectWrapper);\n            dom.onchange.wrapped = true;\n            wrappers.set(dom, selectWrapper);\n        }\n        selectWrapper.vNode = vNode;\n    }\n}\nfunction applyValue$1(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    if (props.multiple !== dom.multiple) {\n        dom.multiple = props.multiple;\n    }\n    var children = vNode.children;\n    var value = props.value;\n    if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n            updateChildOptionGroup(children[i], value);\n        }\n    }\n    else if (isVNode(children)) {\n        updateChildOptionGroup(children, value);\n    }\n}\n\nfunction isControlled$2(props) {\n    return !isNullOrUndef(props.value);\n}\nfunction wrappedOnChange$1(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var event = events.onChange;\n    if (event.event) {\n        event.event(event.data, e);\n    }\n    else {\n        event(e);\n    }\n}\nfunction onTextareaInputChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onInput) {\n        var event = events.onInput;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.oninput) {\n        events.oninput(e);\n    }\n    // the user may have updated the vNode from the above onInput events\n    // so we need to get it from the context of `this` again\n    applyValue$2(this.vNode, dom);\n}\nfunction processTextarea(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue$2(vNode, dom);\n    var textareaWrapper = wrappers.get(dom);\n    if (isControlled$2(props)) {\n        if (!textareaWrapper) {\n            textareaWrapper = {\n                vNode: vNode\n            };\n            dom.oninput = onTextareaInputChange.bind(textareaWrapper);\n            dom.oninput.wrapped = true;\n            if (props.onChange) {\n                dom.onchange = wrappedOnChange$1.bind(textareaWrapper);\n                dom.onchange.wrapped = true;\n            }\n            wrappers.set(dom, textareaWrapper);\n        }\n        textareaWrapper.vNode = vNode;\n    }\n}\nfunction applyValue$2(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    var value = props.value;\n    if (dom.value !== value) {\n        if (!isNullOrUndef(value)) {\n            dom.value = value;\n        }\n    }\n}\n\nvar wrappers = new Map();\nfunction processElement(flags, vNode, dom) {\n    if (flags & 512 /* InputElement */) {\n        processInput(vNode, dom);\n    }\n    else if (flags & 2048 /* SelectElement */) {\n        processSelect(vNode, dom);\n    }\n    else if (flags & 1024 /* TextareaElement */) {\n        processTextarea(vNode, dom);\n    }\n}\n\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var flags = vNode.flags;\n    if (flags & 28 /* Component */) {\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\n    }\n    else if (flags & 3970 /* Element */) {\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\n    }\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\n        unmountVoidOrText(vNode, parentDom);\n    }\n}\nfunction unmountVoidOrText(vNode, parentDom) {\n    if (parentDom) {\n        removeChild(parentDom, vNode.dom);\n    }\n}\nvar alreadyUnmounted = new WeakMap();\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var instance = vNode.children;\n    var flags = vNode.flags;\n    var isStatefulComponent$$1 = flags & 4;\n    var ref = vNode.ref;\n    var dom = vNode.dom;\n    if (alreadyUnmounted.has(vNode) && !isRecycling && !parentDom) {\n        return;\n    }\n    alreadyUnmounted.set(vNode);\n    if (!isRecycling) {\n        if (isStatefulComponent$$1) {\n            if (!instance._unmounted) {\n                instance._ignoreSetState = true;\n                options.beforeUnmount && options.beforeUnmount(vNode);\n                instance.componentWillUnmount && instance.componentWillUnmount();\n                if (ref && !isRecycling) {\n                    ref(null);\n                }\n                instance._unmounted = true;\n                options.findDOMNodeEnabled && componentToDOMNodeMap.delete(instance);\n                var subLifecycle = instance._lifecycle;\n                if (!subLifecycle.fastUnmount) {\n                    unmount(instance._lastInput, null, subLifecycle, false, isRecycling);\n                }\n            }\n        }\n        else {\n            if (!isNullOrUndef(ref)) {\n                if (!isNullOrUndef(ref.onComponentWillUnmount)) {\n                    ref.onComponentWillUnmount(dom);\n                }\n            }\n            if (!lifecycle.fastUnmount) {\n                unmount(instance, null, lifecycle, false, isRecycling);\n            }\n        }\n    }\n    if (parentDom) {\n        var lastInput = instance._lastInput;\n        if (isNullOrUndef(lastInput)) {\n            lastInput = instance;\n        }\n        removeChild(parentDom, dom);\n    }\n    if (options.recyclingEnabled && !isStatefulComponent$$1 && (parentDom || canRecycle)) {\n        poolComponent(vNode);\n    }\n}\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var dom = vNode.dom;\n    var ref = vNode.ref;\n    var events = vNode.events;\n    if (alreadyUnmounted.has(vNode) && !isRecycling && !parentDom) {\n        return;\n    }\n    alreadyUnmounted.set(vNode);\n    if (!lifecycle.fastUnmount) {\n        if (ref && !isRecycling) {\n            unmountRef(ref);\n        }\n        var children = vNode.children;\n        if (!isNullOrUndef(children)) {\n            unmountChildren$1(children, lifecycle, isRecycling);\n        }\n    }\n    if (!isNull(events)) {\n        for (var name in events) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, events[name], null, dom, lifecycle);\n            events[name] = null;\n        }\n    }\n    if (parentDom) {\n        removeChild(parentDom, dom);\n    }\n    if (options.recyclingEnabled && (parentDom || canRecycle)) {\n        poolElement(vNode);\n    }\n}\nfunction unmountChildren$1(children, lifecycle, isRecycling) {\n    if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (!isInvalid(child) && isObject(child)) {\n                unmount(child, null, lifecycle, false, isRecycling);\n            }\n        }\n    }\n    else if (isObject(children)) {\n        unmount(children, null, lifecycle, false, isRecycling);\n    }\n}\nfunction unmountRef(ref) {\n    if (isFunction(ref)) {\n        ref(null);\n    }\n    else {\n        if (isInvalid(ref)) {\n            return;\n        }\n        if (false) {\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        throwError();\n    }\n}\n\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    if (lastVNode !== nextVNode) {\n        var lastFlags = lastVNode.flags;\n        var nextFlags = nextVNode.flags;\n        if (nextFlags & 28 /* Component */) {\n            if (lastFlags & 28 /* Component */) {\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, nextFlags & 4 /* ComponentClass */, isRecycling);\n            }\n            else {\n                replaceVNode(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, nextFlags & 4 /* ComponentClass */), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 3970 /* Element */) {\n            if (lastFlags & 3970 /* Element */) {\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n            }\n            else {\n                replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 1 /* Text */) {\n            if (lastFlags & 1 /* Text */) {\n                patchText(lastVNode, nextVNode);\n            }\n            else {\n                replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 4096 /* Void */) {\n            if (lastFlags & 4096 /* Void */) {\n                patchVoid(lastVNode, nextVNode);\n            }\n            else {\n                replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else {\n            // Error case: mount new one replacing old one\n            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n        }\n    }\n}\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\n    if (isVNode(children)) {\n        unmount(children, dom, lifecycle, true, isRecycling);\n    }\n    else if (isArray(children)) {\n        removeAllChildren(dom, children, lifecycle, isRecycling);\n    }\n    else {\n        dom.textContent = '';\n    }\n}\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    var nextTag = nextVNode.type;\n    var lastTag = lastVNode.type;\n    if (lastTag !== nextTag) {\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n    }\n    else {\n        var dom = lastVNode.dom;\n        var lastProps = lastVNode.props;\n        var nextProps = nextVNode.props;\n        var lastChildren = lastVNode.children;\n        var nextChildren = nextVNode.children;\n        var lastFlags = lastVNode.flags;\n        var nextFlags = nextVNode.flags;\n        var lastRef = lastVNode.ref;\n        var nextRef = nextVNode.ref;\n        var lastEvents = lastVNode.events;\n        var nextEvents = nextVNode.events;\n        nextVNode.dom = dom;\n        if (isSVG || (nextFlags & 128 /* SvgElement */)) {\n            isSVG = true;\n        }\n        if (lastChildren !== nextChildren) {\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        if (!(nextFlags & 2 /* HtmlElement */)) {\n            processElement(nextFlags, nextVNode, dom);\n        }\n        if (lastProps !== nextProps) {\n            patchProps(lastProps, nextProps, dom, lifecycle, context, isSVG);\n        }\n        if (lastEvents !== nextEvents) {\n            patchEvents(lastEvents, nextEvents, dom, lifecycle);\n        }\n        if (nextRef) {\n            if (lastRef !== nextRef || isRecycling) {\n                mountRef(dom, nextRef, lifecycle);\n            }\n        }\n    }\n}\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\n    var patchArray = false;\n    var patchKeyed = false;\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\n        patchArray = true;\n    }\n    else if ((lastFlags & 32 /* HasKeyedChildren */) && (nextFlags & 32 /* HasKeyedChildren */)) {\n        patchKeyed = true;\n        patchArray = true;\n    }\n    else if (isInvalid(nextChildren)) {\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n    }\n    else if (isInvalid(lastChildren)) {\n        if (isStringOrNumber(nextChildren)) {\n            setTextContent(dom, nextChildren);\n        }\n        else {\n            if (isArray(nextChildren)) {\n                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\n            }\n            else {\n                mount(nextChildren, dom, lifecycle, context, isSVG);\n            }\n        }\n    }\n    else if (isStringOrNumber(nextChildren)) {\n        if (isStringOrNumber(lastChildren)) {\n            updateTextContent(dom, nextChildren);\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            setTextContent(dom, nextChildren);\n        }\n    }\n    else if (isArray(nextChildren)) {\n        if (isArray(lastChildren)) {\n            patchArray = true;\n            if (isKeyed(lastChildren, nextChildren)) {\n                patchKeyed = true;\n            }\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\n        }\n    }\n    else if (isArray(lastChildren)) {\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\n        mount(nextChildren, dom, lifecycle, context, isSVG);\n    }\n    else if (isVNode(nextChildren)) {\n        if (isVNode(lastChildren)) {\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            mount(nextChildren, dom, lifecycle, context, isSVG);\n        }\n    } /* else if (isVNode(lastChildren)) {\n        // TODO: One test hits this line when passing invalid children what should be done?\n        // debugger;\n    } else {\n        // debugger;\n    }*/\n    if (patchArray) {\n        if (patchKeyed) {\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n    }\n}\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\n    var lastType = lastVNode.type;\n    var nextType = nextVNode.type;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var lastKey = lastVNode.key;\n    var nextKey = nextVNode.key;\n    var defaultProps = nextType.defaultProps;\n    if (!isUndefined(defaultProps)) {\n        copyPropsTo(defaultProps, nextProps);\n        nextVNode.props = nextProps;\n    }\n    if (lastType !== nextType) {\n        if (isClass) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            var lastInput = lastVNode.children._lastInput || lastVNode.children;\n            var nextInput = createFunctionalComponentInput(nextVNode, nextType, nextProps, context);\n            unmount(lastVNode, null, lifecycle, false, isRecycling);\n            patch(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling);\n            var dom = nextVNode.dom = nextInput.dom;\n            nextVNode.children = nextInput;\n            mountFunctionalComponentCallbacks(nextVNode.ref, dom, lifecycle);\n        }\n    }\n    else {\n        if (isClass) {\n            if (lastKey !== nextKey) {\n                replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n                return false;\n            }\n            var instance = lastVNode.children;\n            if (instance._unmounted) {\n                if (isNull(parentDom)) {\n                    return true;\n                }\n                replaceChild(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, nextVNode.flags & 4 /* ComponentClass */), lastVNode.dom);\n            }\n            else {\n                var lastState = instance.state;\n                var nextState = instance.state;\n                var lastProps = instance.props;\n                var childContext = instance.getChildContext();\n                nextVNode.children = instance;\n                instance._isSVG = isSVG;\n                if (!isNullOrUndef(childContext)) {\n                    childContext = Object.assign({}, context, childContext);\n                }\n                else {\n                    childContext = context;\n                }\n                var lastInput$1 = instance._lastInput;\n                var nextInput$1 = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\n                var didUpdate = true;\n                instance._childContext = childContext;\n                if (isInvalid(nextInput$1)) {\n                    nextInput$1 = createVoidVNode();\n                }\n                else if (nextInput$1 === NO_OP) {\n                    nextInput$1 = lastInput$1;\n                    didUpdate = false;\n                }\n                else if (isStringOrNumber(nextInput$1)) {\n                    nextInput$1 = createTextVNode(nextInput$1);\n                }\n                else if (isArray(nextInput$1)) {\n                    if (false) {\n                        throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n                    }\n                    throwError();\n                }\n                else if (isObject(nextInput$1) && nextInput$1.dom) {\n                    nextInput$1 = cloneVNode(nextInput$1);\n                }\n                if (nextInput$1.flags & 28 /* Component */) {\n                    nextInput$1.parentVNode = nextVNode;\n                }\n                else if (lastInput$1.flags & 28 /* Component */) {\n                    lastInput$1.parentVNode = nextVNode;\n                }\n                instance._lastInput = nextInput$1;\n                instance._vNode = nextVNode;\n                if (didUpdate) {\n                    var fastUnmount = lifecycle.fastUnmount;\n                    var subLifecycle = instance._lifecycle;\n                    lifecycle.fastUnmount = subLifecycle.fastUnmount;\n                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, childContext, isSVG, isRecycling);\n                    subLifecycle.fastUnmount = lifecycle.fastUnmount;\n                    lifecycle.fastUnmount = fastUnmount;\n                    instance.componentDidUpdate(lastProps, lastState);\n                    options.afterUpdate && options.afterUpdate(nextVNode);\n                    options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, nextInput$1.dom);\n                }\n                nextVNode.dom = nextInput$1.dom;\n            }\n        }\n        else {\n            var shouldUpdate = true;\n            var lastProps$1 = lastVNode.props;\n            var nextHooks = nextVNode.ref;\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\n            var lastInput$2 = lastVNode.children;\n            var nextInput$2 = lastInput$2;\n            nextVNode.dom = lastVNode.dom;\n            nextVNode.children = lastInput$2;\n            if (lastKey !== nextKey) {\n                shouldUpdate = true;\n            }\n            else {\n                if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);\n                }\n            }\n            if (shouldUpdate !== false) {\n                if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentWillUpdate)) {\n                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);\n                }\n                nextInput$2 = nextType(nextProps, context);\n                if (isInvalid(nextInput$2)) {\n                    nextInput$2 = createVoidVNode();\n                }\n                else if (isStringOrNumber(nextInput$2) && nextInput$2 !== NO_OP) {\n                    nextInput$2 = createTextVNode(nextInput$2);\n                }\n                else if (isArray(nextInput$2)) {\n                    if (false) {\n                        throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n                    }\n                    throwError();\n                }\n                else if (isObject(nextInput$2) && nextInput$2.dom) {\n                    nextInput$2 = cloneVNode(nextInput$2);\n                }\n                if (nextInput$2 !== NO_OP) {\n                    patch(lastInput$2, nextInput$2, parentDom, lifecycle, context, isSVG, isRecycling);\n                    nextVNode.children = nextInput$2;\n                    if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentDidUpdate)) {\n                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);\n                    }\n                    nextVNode.dom = nextInput$2.dom;\n                }\n            }\n            if (nextInput$2.flags & 28 /* Component */) {\n                nextInput$2.parentVNode = nextVNode;\n            }\n            else if (lastInput$2.flags & 28 /* Component */) {\n                lastInput$2.parentVNode = nextVNode;\n            }\n        }\n    }\n    return false;\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = lastVNode.dom;\n    nextVNode.dom = dom;\n    if (lastVNode.children !== nextText) {\n        dom.nodeValue = nextText;\n    }\n}\nfunction patchVoid(lastVNode, nextVNode) {\n    nextVNode.dom = lastVNode.dom;\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\n    var lastChildrenLength = lastChildren.length;\n    var nextChildrenLength = nextChildren.length;\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    for (; i < commonLength; i++) {\n        var nextChild = nextChildren[i];\n        if (nextChild.dom) {\n            nextChild = nextChildren[i] = cloneVNode(nextChild);\n        }\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; i++) {\n            var nextChild$1 = nextChildren[i];\n            if (nextChild$1.dom) {\n                nextChild$1 = nextChildren[i] = cloneVNode(nextChild$1);\n            }\n            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));\n        }\n    }\n    else if (nextChildrenLength === 0) {\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; i++) {\n            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\n    var aLength = a.length;\n    var bLength = b.length;\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var aStart = 0;\n    var bStart = 0;\n    var i;\n    var j;\n    var aNode;\n    var bNode;\n    var nextNode;\n    var nextPos;\n    var node;\n    if (aLength === 0) {\n        if (bLength !== 0) {\n            mountArrayChildren(b, dom, lifecycle, context, isSVG);\n        }\n        return;\n    }\n    else if (bLength === 0) {\n        removeAllChildren(dom, a, lifecycle, isRecycling);\n        return;\n    }\n    var aStartNode = a[aStart];\n    var bStartNode = b[bStart];\n    var aEndNode = a[aEnd];\n    var bEndNode = b[bEnd];\n    if (bStartNode.dom) {\n        b[bStart] = bStartNode = cloneVNode(bStartNode);\n    }\n    if (bEndNode.dom) {\n        b[bEnd] = bEndNode = cloneVNode(bEndNode);\n    }\n    // Step 1\n    /* eslint no-constant-condition: 0 */\n    outer: while (true) {\n        // Sync nodes with the same key at the beginning.\n        while (aStartNode.key === bStartNode.key) {\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\n            aStart++;\n            bStart++;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aStartNode = a[aStart];\n            bStartNode = b[bStart];\n            if (bStartNode.dom) {\n                b[bStart] = bStartNode = cloneVNode(bStartNode);\n            }\n        }\n        // Sync nodes with the same key at the end.\n        while (aEndNode.key === bEndNode.key) {\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\n            aEnd--;\n            bEnd--;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aEndNode = a[aEnd];\n            bEndNode = b[bEnd];\n            if (bEndNode.dom) {\n                b[bEnd] = bEndNode = cloneVNode(bEndNode);\n            }\n        }\n        // Move and sync nodes from right to left.\n        if (aEndNode.key === bStartNode.key) {\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\n            insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\n            aEnd--;\n            bStart++;\n            aEndNode = a[aEnd];\n            bStartNode = b[bStart];\n            if (bStartNode.dom) {\n                b[bStart] = bStartNode = cloneVNode(bStartNode);\n            }\n            continue;\n        }\n        // Move and sync nodes from left to right.\n        if (aStartNode.key === bEndNode.key) {\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\n            nextPos = bEnd + 1;\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n            insertOrAppend(dom, bEndNode.dom, nextNode);\n            aStart++;\n            bEnd--;\n            aStartNode = a[aStart];\n            bEndNode = b[bEnd];\n            if (bEndNode.dom) {\n                b[bEnd] = bEndNode = cloneVNode(bEndNode);\n            }\n            continue;\n        }\n        break;\n    }\n    if (aStart > aEnd) {\n        if (bStart <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n            while (bStart <= bEnd) {\n                node = b[bStart];\n                if (node.dom) {\n                    b[bStart] = node = cloneVNode(node);\n                }\n                bStart++;\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\n            }\n        }\n    }\n    else if (bStart > bEnd) {\n        while (aStart <= aEnd) {\n            unmount(a[aStart++], dom, lifecycle, false, isRecycling);\n        }\n    }\n    else {\n        aLength = aEnd - aStart + 1;\n        bLength = bEnd - bStart + 1;\n        var aNullable = a;\n        var sources = new Array(bLength);\n        // Mark all nodes as inserted.\n        for (i = 0; i < bLength; i++) {\n            sources[i] = -1;\n        }\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        if ((bLength <= 4) || (aLength * bLength <= 16)) {\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLength) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i;\n                            if (pos > j) {\n                                moved = true;\n                            }\n                            else {\n                                pos = j;\n                            }\n                            if (bNode.dom) {\n                                b[j] = bNode = cloneVNode(bNode);\n                            }\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\n                            patched++;\n                            aNullable[i] = null;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            var keyIndex = new Map();\n            for (i = bStart; i <= bEnd; i++) {\n                node = b[i];\n                keyIndex.set(node.key, i);\n            }\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLength) {\n                    j = keyIndex.get(aNode.key);\n                    if (!isUndefined(j)) {\n                        bNode = b[j];\n                        sources[j - bStart] = i;\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.dom) {\n                            b[j] = bNode = cloneVNode(bNode);\n                        }\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\n                        patched++;\n                        aNullable[i] = null;\n                    }\n                }\n            }\n        }\n        if (aLength === a.length && patched === 0) {\n            removeAllChildren(dom, a, lifecycle, isRecycling);\n            while (bStart < bLength) {\n                node = b[bStart];\n                if (node.dom) {\n                    b[bStart] = node = cloneVNode(node);\n                }\n                bStart++;\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);\n            }\n        }\n        else {\n            i = aLength - patched;\n            while (i > 0) {\n                aNode = aNullable[aStart++];\n                if (!isNull(aNode)) {\n                    unmount(aNode, dom, lifecycle, true, isRecycling);\n                    i--;\n                }\n            }\n            if (moved) {\n                var seq = lis_algorithm(sources);\n                j = seq.length - 1;\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        if (node.dom) {\n                            b[pos] = node = cloneVNode(node);\n                        }\n                        nextPos = pos + 1;\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                        insertOrAppend(dom, mount(node, dom, lifecycle, context, isSVG), nextNode);\n                    }\n                    else {\n                        if (j < 0 || i !== seq[j]) {\n                            pos = i + bStart;\n                            node = b[pos];\n                            nextPos = pos + 1;\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                            insertOrAppend(dom, node.dom, nextNode);\n                        }\n                        else {\n                            j--;\n                        }\n                    }\n                }\n            }\n            else if (patched !== bLength) {\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        if (node.dom) {\n                            b[pos] = node = cloneVNode(node);\n                        }\n                        nextPos = pos + 1;\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\n                    }\n                }\n            }\n        }\n    }\n}\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(a) {\n    var p = a.slice(0);\n    var result = [];\n    result.push(0);\n    var i;\n    var j;\n    var u;\n    var v;\n    var c;\n    for (i = 0; i < a.length; i++) {\n        if (a[i] === -1) {\n            continue;\n        }\n        j = result[result.length - 1];\n        if (a[j] < a[i]) {\n            p[i] = j;\n            result.push(i);\n            continue;\n        }\n        u = 0;\n        v = result.length - 1;\n        while (u < v) {\n            c = ((u + v) / 2) | 0;\n            if (a[result[c]] < a[i]) {\n                u = c + 1;\n            }\n            else {\n                v = c;\n            }\n        }\n        if (a[i] < a[result[u]]) {\n            if (u > 0) {\n                p[i] = result[u - 1];\n            }\n            result[u] = i;\n        }\n    }\n    u = result.length;\n    v = result[u - 1];\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n    return result;\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, lifecycle) {\n    if (skipProps[prop]) {\n        return;\n    }\n    if (booleanProps[prop]) {\n        dom[prop] = nextValue ? true : false;\n    }\n    else if (strictProps[prop]) {\n        var value = isNullOrUndef(nextValue) ? '' : nextValue;\n        if (dom[prop] !== value) {\n            dom[prop] = value;\n        }\n    }\n    else if (lastValue !== nextValue) {\n        if (isAttrAnEvent(prop)) {\n            patchEvent(prop, lastValue, nextValue, dom, lifecycle);\n        }\n        else if (isNullOrUndef(nextValue)) {\n            dom.removeAttribute(prop);\n        }\n        else if (prop === 'className') {\n            if (isSVG) {\n                dom.setAttribute('class', nextValue);\n            }\n            else {\n                dom.className = nextValue;\n            }\n        }\n        else if (prop === 'style') {\n            patchStyle(lastValue, nextValue, dom);\n        }\n        else if (prop === 'dangerouslySetInnerHTML') {\n            var lastHtml = lastValue && lastValue.__html;\n            var nextHtml = nextValue && nextValue.__html;\n            if (lastHtml !== nextHtml) {\n                if (!isNullOrUndef(nextHtml)) {\n                    dom.innerHTML = nextHtml;\n                }\n            }\n        }\n        else if (prop !== 'childrenType' && prop !== 'ref' && prop !== 'key') {\n            var dehyphenProp;\n            if (dehyphenProps[prop]) {\n                dehyphenProp = dehyphenProps[prop];\n            }\n            else if (isSVG && prop.match(probablyKebabProps)) {\n                dehyphenProp = prop.replace(/([a-z])([A-Z]|1)/g, kebabize);\n                dehyphenProps[prop] = dehyphenProp;\n            }\n            else {\n                dehyphenProp = prop;\n            }\n            var ns = namespaces[prop];\n            if (ns) {\n                dom.setAttributeNS(ns, dehyphenProp, nextValue);\n            }\n            else {\n                dom.setAttribute(dehyphenProp, nextValue);\n            }\n        }\n    }\n}\nfunction patchEvents(lastEvents, nextEvents, dom, lifecycle) {\n    lastEvents = lastEvents || EMPTY_OBJ;\n    nextEvents = nextEvents || EMPTY_OBJ;\n    if (nextEvents !== EMPTY_OBJ) {\n        for (var name in nextEvents) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, lastEvents[name], nextEvents[name], dom, lifecycle);\n        }\n    }\n    if (lastEvents !== EMPTY_OBJ) {\n        for (var name$1 in lastEvents) {\n            // do not add a hasOwnProperty check here, it affects performance\n            if (isNullOrUndef(nextEvents[name$1])) {\n                patchEvent(name$1, lastEvents[name$1], null, dom, lifecycle);\n            }\n        }\n    }\n}\nfunction patchEvent(name, lastValue, nextValue, dom, lifecycle) {\n    if (lastValue !== nextValue) {\n        var nameLowerCase = name.toLowerCase();\n        var domEvent = dom[nameLowerCase];\n        // if the function is wrapped, that means it's been controlled by a wrapper\n        if (domEvent && domEvent.wrapped) {\n            return;\n        }\n        if (delegatedProps[name]) {\n            handleEvent(name, lastValue, nextValue, dom);\n        }\n        else {\n            if (lastValue !== nextValue) {\n                if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\n                    var linkEvent = nextValue.event;\n                    if (linkEvent && isFunction(linkEvent)) {\n                        if (!dom._data) {\n                            dom[nameLowerCase] = function (e) {\n                                linkEvent(e.currentTarget._data, e);\n                            };\n                        }\n                        dom._data = nextValue.data;\n                    }\n                    else {\n                        if (false) {\n                            throwError((\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\"));\n                        }\n                        throwError();\n                    }\n                }\n                else {\n                    dom[nameLowerCase] = nextValue;\n                }\n            }\n        }\n    }\n}\nfunction patchProps(lastProps, nextProps, dom, lifecycle, context, isSVG) {\n    lastProps = lastProps || EMPTY_OBJ;\n    nextProps = nextProps || EMPTY_OBJ;\n    if (nextProps !== EMPTY_OBJ) {\n        for (var prop in nextProps) {\n            // do not add a hasOwnProperty check here, it affects performance\n            var nextValue = nextProps[prop];\n            var lastValue = lastProps[prop];\n            if (isNullOrUndef(nextValue)) {\n                removeProp(prop, nextValue, dom);\n            }\n            else {\n                patchProp(prop, lastValue, nextValue, dom, isSVG, lifecycle);\n            }\n        }\n    }\n    if (lastProps !== EMPTY_OBJ) {\n        for (var prop$1 in lastProps) {\n            // do not add a hasOwnProperty check here, it affects performance\n            if (isNullOrUndef(nextProps[prop$1])) {\n                removeProp(prop$1, lastProps[prop$1], dom);\n            }\n        }\n    }\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isString(nextAttrValue)) {\n        dom.style.cssText = nextAttrValue;\n        return;\n    }\n    for (var style in nextAttrValue) {\n        // do not add a hasOwnProperty check here, it affects performance\n        var value = nextAttrValue[style];\n        if (isNumber(value) && !isUnitlessNumber[style]) {\n            dom.style[style] = value + 'px';\n        }\n        else {\n            dom.style[style] = value;\n        }\n    }\n    if (!isNullOrUndef(lastAttrValue)) {\n        for (var style$1 in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style$1])) {\n                dom.style[style$1] = '';\n            }\n        }\n    }\n}\nfunction removeProp(prop, lastValue, dom) {\n    if (prop === 'className') {\n        dom.removeAttribute('class');\n    }\n    else if (prop === 'value') {\n        dom.value = '';\n    }\n    else if (prop === 'style') {\n        dom.removeAttribute('style');\n    }\n    else if (isAttrAnEvent(prop)) {\n        handleEvent(name, lastValue, null, dom);\n    }\n    else {\n        dom.removeAttribute(prop);\n    }\n}\n\nvar componentPools = new Map();\nvar elementPools = new Map();\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\n    var tag = vNode.type;\n    var key = vNode.key;\n    var pools = elementPools.get(tag);\n    if (!isUndefined(pools)) {\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\n        if (!isUndefined(pool)) {\n            var recycledVNode = pool.pop();\n            if (!isUndefined(recycledVNode)) {\n                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\n                return vNode.dom;\n            }\n        }\n    }\n    return null;\n}\nfunction poolElement(vNode) {\n    var tag = vNode.type;\n    var key = vNode.key;\n    var pools = elementPools.get(tag);\n    if (isUndefined(pools)) {\n        pools = {\n            nonKeyed: [],\n            keyed: new Map()\n        };\n        elementPools.set(tag, pools);\n    }\n    if (isNull(key)) {\n        pools.nonKeyed.push(vNode);\n    }\n    else {\n        var pool = pools.keyed.get(key);\n        if (isUndefined(pool)) {\n            pool = [];\n            pools.keyed.set(key, pool);\n        }\n        pool.push(vNode);\n    }\n}\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\n    var type = vNode.type;\n    var key = vNode.key;\n    var pools = componentPools.get(type);\n    if (!isUndefined(pools)) {\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\n        if (!isUndefined(pool)) {\n            var recycledVNode = pool.pop();\n            if (!isUndefined(recycledVNode)) {\n                var flags = vNode.flags;\n                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, flags & 4 /* ComponentClass */, true);\n                if (!failed) {\n                    return vNode.dom;\n                }\n            }\n        }\n    }\n    return null;\n}\nfunction poolComponent(vNode) {\n    var type = vNode.type;\n    var key = vNode.key;\n    var hooks = vNode.ref;\n    var nonRecycleHooks = hooks && (hooks.onComponentWillMount ||\n        hooks.onComponentWillUnmount ||\n        hooks.onComponentDidMount ||\n        hooks.onComponentWillUpdate ||\n        hooks.onComponentDidUpdate);\n    if (nonRecycleHooks) {\n        return;\n    }\n    var pools = componentPools.get(type);\n    if (isUndefined(pools)) {\n        pools = {\n            nonKeyed: [],\n            keyed: new Map()\n        };\n        componentPools.set(type, pools);\n    }\n    if (isNull(key)) {\n        pools.nonKeyed.push(vNode);\n    }\n    else {\n        var pool = pools.keyed.get(key);\n        if (isUndefined(pool)) {\n            pool = [];\n            pools.keyed.set(key, pool);\n        }\n        pool.push(vNode);\n    }\n}\n\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\n    var flags = vNode.flags;\n    if (flags & 3970 /* Element */) {\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\n    }\n    else if (flags & 28 /* Component */) {\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, flags & 4 /* ComponentClass */);\n    }\n    else if (flags & 4096 /* Void */) {\n        return mountVoid(vNode, parentDom);\n    }\n    else if (flags & 1 /* Text */) {\n        return mountText(vNode, parentDom);\n    }\n    else {\n        if (false) {\n            if (typeof vNode === 'object') {\n                throwError((\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + (JSON.stringify(vNode)) + \"\\\".\"));\n            }\n            else {\n                throwError((\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\n            }\n        }\n        throwError();\n    }\n}\nfunction mountText(vNode, parentDom) {\n    var dom = document.createTextNode(vNode.children);\n    vNode.dom = dom;\n    if (parentDom) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountVoid(vNode, parentDom) {\n    var dom = document.createTextNode('');\n    vNode.dom = dom;\n    if (parentDom) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\n    if (options.recyclingEnabled) {\n        var dom$1 = recycleElement(vNode, lifecycle, context, isSVG);\n        if (!isNull(dom$1)) {\n            if (!isNull(parentDom)) {\n                appendChild(parentDom, dom$1);\n            }\n            return dom$1;\n        }\n    }\n    var tag = vNode.type;\n    var flags = vNode.flags;\n    if (isSVG || (flags & 128 /* SvgElement */)) {\n        isSVG = true;\n    }\n    var dom = documentCreateElement(tag, isSVG);\n    var children = vNode.children;\n    var props = vNode.props;\n    var events = vNode.events;\n    var ref = vNode.ref;\n    vNode.dom = dom;\n    if (!isNull(children)) {\n        if (isStringOrNumber(children)) {\n            setTextContent(dom, children);\n        }\n        else if (isArray(children)) {\n            mountArrayChildren(children, dom, lifecycle, context, isSVG);\n        }\n        else if (isVNode(children)) {\n            mount(children, dom, lifecycle, context, isSVG);\n        }\n    }\n    if (!(flags & 2 /* HtmlElement */)) {\n        processElement(flags, vNode, dom);\n    }\n    if (!isNull(props)) {\n        for (var prop in props) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchProp(prop, null, props[prop], dom, isSVG, lifecycle);\n        }\n    }\n    if (!isNull(events)) {\n        for (var name in events) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, null, events[name], dom, lifecycle);\n        }\n    }\n    if (!isNull(ref)) {\n        mountRef(dom, ref, lifecycle);\n    }\n    if (!isNull(parentDom)) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (!isInvalid(child)) {\n            if (child.dom) {\n                children[i] = child = cloneVNode(child);\n            }\n            mount(children[i], dom, lifecycle, context, isSVG);\n        }\n    }\n}\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\n    if (options.recyclingEnabled) {\n        var dom$1 = recycleComponent(vNode, lifecycle, context, isSVG);\n        if (!isNull(dom$1)) {\n            if (!isNull(parentDom)) {\n                appendChild(parentDom, dom$1);\n            }\n            return dom$1;\n        }\n    }\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var defaultProps = type.defaultProps;\n    var ref = vNode.ref;\n    var dom;\n    if (!isUndefined(defaultProps)) {\n        copyPropsTo(defaultProps, props);\n        vNode.props = props;\n    }\n    if (isClass) {\n        var instance = createClassComponentInstance(vNode, type, props, context, isSVG);\n        // If instance does not have componentWillUnmount specified we can enable fastUnmount\n        var input = instance._lastInput;\n        var prevFastUnmount = lifecycle.fastUnmount;\n        // we store the fastUnmount value, but we set it back to true on the lifecycle\n        // we do this so we can determine if the component render has a fastUnmount or not\n        lifecycle.fastUnmount = true;\n        instance._vNode = vNode;\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\n        // we now create a lifecycle for this component and store the fastUnmount value\n        var subLifecycle = instance._lifecycle = new Lifecycle();\n        // children lifecycle can fastUnmount if itself does need unmount callback and within its cycle there was none\n        subLifecycle.fastUnmount = isUndefined(instance.componentWillUnmount) && lifecycle.fastUnmount;\n        // higher lifecycle can fastUnmount only if previously it was able to and this children doesnt have any\n        lifecycle.fastUnmount = prevFastUnmount && subLifecycle.fastUnmount;\n        if (!isNull(parentDom)) {\n            appendChild(parentDom, dom);\n        }\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, dom);\n        vNode.children = instance;\n    }\n    else {\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\n        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);\n        vNode.children = input$1;\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n        if (!isNull(parentDom)) {\n            appendChild(parentDom, dom);\n        }\n    }\n    return dom;\n}\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\n    if (ref) {\n        if (isFunction(ref)) {\n            ref(instance);\n        }\n        else {\n            if (false) {\n                if (isStringOrNumber(ref)) {\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n                }\n                else if (isObject(ref) && (vNode.flags & 4 /* ComponentClass */)) {\n                    throwError('functional component lifecycle events are not supported on ES2015 class components.');\n                }\n                else {\n                    throwError((\"a bad value for \\\"ref\\\" was used on component: \\\"\" + (JSON.stringify(ref)) + \"\\\"\"));\n                }\n            }\n            throwError();\n        }\n    }\n    var cDM = instance.componentDidMount;\n    var afterMount = options.afterMount;\n    if (!isUndefined(cDM) || !isNull(afterMount)) {\n        lifecycle.addListener(function () {\n            afterMount && afterMount(vNode);\n            cDM && instance.componentDidMount();\n        });\n    }\n}\nfunction mountFunctionalComponentCallbacks(ref, dom, lifecycle) {\n    if (ref) {\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\n            ref.onComponentWillMount();\n        }\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\n            lifecycle.addListener(function () { return ref.onComponentDidMount(dom); });\n        }\n        if (!isNullOrUndef(ref.onComponentWillUnmount)) {\n            lifecycle.fastUnmount = false;\n        }\n    }\n}\nfunction mountRef(dom, value, lifecycle) {\n    if (isFunction(value)) {\n        lifecycle.fastUnmount = false;\n        lifecycle.addListener(function () { return value(dom); });\n    }\n    else {\n        if (isInvalid(value)) {\n            return;\n        }\n        if (false) {\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        throwError();\n    }\n}\n\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG) {\n    if (isUndefined(context)) {\n        context = {};\n    }\n    var instance = new Component(props, context);\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    instance._patch = patch;\n    if (options.findDOMNodeEnabled) {\n        instance._componentToDOMNodeMap = componentToDOMNodeMap;\n    }\n    instance._unmounted = false;\n    instance._pendingSetState = true;\n    instance._isSVG = isSVG;\n    instance.componentWillMount();\n    var childContext = instance.getChildContext();\n    if (!isNullOrUndef(childContext)) {\n        instance._childContext = Object.assign({}, context, childContext);\n    }\n    else {\n        instance._childContext = context;\n    }\n    options.beforeRender && options.beforeRender(instance);\n    var input = instance.render(props, instance.state, context);\n    options.afterRender && options.afterRender(instance);\n    if (isArray(input)) {\n        if (false) {\n            throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        throwError();\n    }\n    else if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input);\n    }\n    else {\n        if (input.dom) {\n            input = cloneVNode(input);\n        }\n        if (input.flags & 28 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = vNode;\n        }\n    }\n    instance._pendingSetState = false;\n    instance._lastInput = input;\n    return instance;\n}\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\n}\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\n    var shallowUnmount = false;\n    // we cannot cache nodeType here as vNode might be re-assigned below\n    if (vNode.flags & 28 /* Component */) {\n        // if we are accessing a stateful or stateless component, we want to access their last rendered input\n        // accessing their DOM node is not useful to us here\n        unmount(vNode, null, lifecycle, false, isRecycling);\n        vNode = vNode.children._lastInput || vNode.children;\n        shallowUnmount = true;\n    }\n    replaceChild(parentDom, dom, vNode.dom);\n    unmount(vNode, null, lifecycle, false, isRecycling);\n}\nfunction createFunctionalComponentInput(vNode, component, props, context) {\n    var input = component(props, context);\n    if (isArray(input)) {\n        if (false) {\n            throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        throwError();\n    }\n    else if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input);\n    }\n    else {\n        if (input.dom) {\n            input = cloneVNode(input);\n        }\n        if (input.flags & 28 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = vNode;\n        }\n    }\n    return input;\n}\nfunction setTextContent(dom, text) {\n    if (text !== '') {\n        dom.textContent = text;\n    }\n    else {\n        dom.appendChild(document.createTextNode(''));\n    }\n}\nfunction updateTextContent(dom, text) {\n    dom.firstChild.nodeValue = text;\n}\nfunction appendChild(parentDom, dom) {\n    parentDom.appendChild(dom);\n}\nfunction insertOrAppend(parentDom, newNode, nextNode) {\n    if (isNullOrUndef(nextNode)) {\n        appendChild(parentDom, newNode);\n    }\n    else {\n        parentDom.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG === true) {\n        return document.createElementNS(svgNS, tag);\n    }\n    else {\n        return document.createElement(tag);\n    }\n}\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    unmount(lastNode, null, lifecycle, false, isRecycling);\n    var dom = mount(nextNode, null, lifecycle, context, isSVG);\n    nextNode.dom = dom;\n    replaceChild(parentDom, dom, lastNode.dom);\n}\nfunction replaceChild(parentDom, nextDom, lastDom) {\n    if (!parentDom) {\n        parentDom = lastDom.parentNode;\n    }\n    parentDom.replaceChild(nextDom, lastDom);\n}\nfunction removeChild(parentDom, dom) {\n    parentDom.removeChild(dom);\n}\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\n    dom.textContent = '';\n    if (!lifecycle.fastUnmount || (lifecycle.fastUnmount && options.recyclingEnabled && !isRecycling)) {\n        removeChildren(null, children, lifecycle, isRecycling);\n    }\n}\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (!isInvalid(child)) {\n            unmount(child, dom, lifecycle, true, isRecycling);\n        }\n    }\n}\nfunction isKeyed(lastChildren, nextChildren) {\n    return nextChildren.length && !isNullOrUndef(nextChildren[0]) && !isNullOrUndef(nextChildren[0].key)\n        && lastChildren.length && !isNullOrUndef(lastChildren[0]) && !isNullOrUndef(lastChildren[0].key);\n}\n\nfunction normalizeChildNodes(parentDom) {\n    var dom = parentDom.firstChild;\n    while (dom) {\n        if (dom.nodeType === 8) {\n            if (dom.data === '!') {\n                var placeholder = document.createTextNode('');\n                parentDom.replaceChild(placeholder, dom);\n                dom = dom.nextSibling;\n            }\n            else {\n                var lastDom = dom.previousSibling;\n                parentDom.removeChild(dom);\n                dom = lastDom || parentDom.firstChild;\n            }\n        }\n        else {\n            dom = dom.nextSibling;\n        }\n    }\n}\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var ref = vNode.ref;\n    vNode.dom = dom;\n    if (isClass) {\n        var _isSVG = dom.namespaceURI === svgNS;\n        var defaultProps = type.defaultProps;\n        if (!isUndefined(defaultProps)) {\n            copyPropsTo(defaultProps, props);\n            vNode.props = props;\n        }\n        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG);\n        // If instance does not have componentWillUnmount specified we can enable fastUnmount\n        var prevFastUnmount = lifecycle.fastUnmount;\n        var input = instance._lastInput;\n        // we store the fastUnmount value, but we set it back to true on the lifecycle\n        // we do this so we can determine if the component render has a fastUnmount or not\n        lifecycle.fastUnmount = true;\n        instance._vComponent = vNode;\n        instance._vNode = vNode;\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\n        // we now create a lifecycle for this component and store the fastUnmount value\n        var subLifecycle = instance._lifecycle = new Lifecycle();\n        // children lifecycle can fastUnmount if itself does need unmount callback and within its cycle there was none\n        subLifecycle.fastUnmount = isUndefined(instance.componentWillUnmount) && lifecycle.fastUnmount;\n        // higher lifecycle can fastUnmount only if previously it was able to and this children doesnt have any\n        lifecycle.fastUnmount = prevFastUnmount && subLifecycle.fastUnmount;\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, dom);\n        vNode.children = instance;\n    }\n    else {\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\n        hydrate(input$1, dom, lifecycle, context, isSVG);\n        vNode.children = input$1;\n        vNode.dom = input$1.dom;\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n    }\n    return dom;\n}\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\n    var tag = vNode.type;\n    var children = vNode.children;\n    var props = vNode.props;\n    var events = vNode.events;\n    var flags = vNode.flags;\n    var ref = vNode.ref;\n    if (isSVG || (flags & 128 /* SvgElement */)) {\n        isSVG = true;\n    }\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== tag) {\n        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);\n        vNode.dom = newDom;\n        replaceChild(dom.parentNode, newDom, dom);\n        return newDom;\n    }\n    vNode.dom = dom;\n    if (children) {\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\n    }\n    if (!(flags & 2 /* HtmlElement */)) {\n        processElement(flags, vNode, dom);\n    }\n    if (props) {\n        for (var prop in props) {\n            patchProp(prop, null, props[prop], dom, isSVG, lifecycle);\n        }\n    }\n    if (events) {\n        for (var name in events) {\n            patchEvent(name, null, events[name], dom, lifecycle);\n        }\n    }\n    if (ref) {\n        mountRef(dom, ref, lifecycle);\n    }\n    return dom;\n}\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\n    normalizeChildNodes(parentDom);\n    var dom = parentDom.firstChild;\n    if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (isObject(child) && !isNull(child)) {\n                if (dom) {\n                    dom = hydrate(child, dom, lifecycle, context, isSVG);\n                    dom = dom.nextSibling;\n                }\n                else {\n                    mount(child, parentDom, lifecycle, context, isSVG);\n                }\n            }\n        }\n    }\n    else if (isStringOrNumber(children)) {\n        if (dom && dom.nodeType === 3) {\n            if (dom.nodeValue !== children) {\n                dom.nodeValue = children;\n            }\n        }\n        else if (children) {\n            parentDom.textContent = children;\n        }\n        dom = dom.nextSibling;\n    }\n    else if (isObject(children)) {\n        hydrate(children, dom, lifecycle, context, isSVG);\n        dom = dom.nextSibling;\n    }\n    // clear any other DOM nodes, there should be only a single entry for the root\n    while (dom) {\n        parentDom.removeChild(dom);\n        dom = dom.nextSibling;\n    }\n}\nfunction hydrateText(vNode, dom) {\n    if (dom.nodeType !== 3) {\n        var newDom = mountText(vNode, null);\n        vNode.dom = newDom;\n        replaceChild(dom.parentNode, newDom, dom);\n        return newDom;\n    }\n    var text = vNode.children;\n    if (dom.nodeValue !== text) {\n        dom.nodeValue = text;\n    }\n    vNode.dom = dom;\n    return dom;\n}\nfunction hydrateVoid(vNode, dom) {\n    vNode.dom = dom;\n}\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\n    if (false) {\n        if (isInvalid(dom)) {\n            throwError(\"failed to hydrate. The server-side render doesn't match client side.\");\n        }\n    }\n    var flags = vNode.flags;\n    if (flags & 28 /* Component */) {\n        return hydrateComponent(vNode, dom, lifecycle, context, isSVG, flags & 4 /* ComponentClass */);\n    }\n    else if (flags & 3970 /* Element */) {\n        return hydrateElement(vNode, dom, lifecycle, context, isSVG);\n    }\n    else if (flags & 1 /* Text */) {\n        return hydrateText(vNode, dom);\n    }\n    else if (flags & 4096 /* Void */) {\n        return hydrateVoid(vNode, dom);\n    }\n    else {\n        if (false) {\n            throwError((\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\n        }\n        throwError();\n    }\n}\nfunction hydrateRoot(input, parentDom, lifecycle) {\n    var dom = parentDom && parentDom.firstChild;\n    if (dom) {\n        hydrate(input, dom, lifecycle, {}, false);\n        dom = parentDom.firstChild;\n        // clear any other DOM nodes, there should be only a single entry for the root\n        while (dom = dom.nextSibling) {\n            parentDom.removeChild(dom);\n        }\n        return true;\n    }\n    return false;\n}\n\n// rather than use a Map, like we did before, we can use an array here\n// given there shouldn't be THAT many roots on the page, the difference\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\nvar roots = [];\nvar componentToDOMNodeMap = new Map();\noptions.roots = roots;\nfunction findDOMNode(ref) {\n    if (!options.findDOMNodeEnabled) {\n        if (false) {\n            throwError('findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!');\n        }\n        throwError();\n    }\n    var dom = ref && ref.nodeType ? ref : null;\n    return componentToDOMNodeMap.get(ref) || dom;\n}\nfunction getRoot(dom) {\n    for (var i = 0; i < roots.length; i++) {\n        var root = roots[i];\n        if (root.dom === dom) {\n            return root;\n        }\n    }\n    return null;\n}\n\nfunction setRoot(dom, input, lifecycle) {\n    var root = {\n        dom: dom,\n        input: input,\n        lifecycle: lifecycle\n    };\n    roots.push(root);\n    return root;\n}\nfunction removeRoot(root) {\n    for (var i = 0; i < roots.length; i++) {\n        if (roots[i] === root) {\n            roots.splice(i, 1);\n            return;\n        }\n    }\n}\nvar documentBody = isBrowser ? document.body : null;\nfunction render(input, parentDom) {\n    if (documentBody === parentDom) {\n        if (false) {\n            throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\n        }\n        throwError();\n    }\n    if (input === NO_OP) {\n        return;\n    }\n    var root = getRoot(parentDom);\n    if (isNull(root)) {\n        var lifecycle = new Lifecycle();\n        if (!isInvalid(input)) {\n            if (input.dom) {\n                input = cloneVNode(input);\n            }\n            if (!hydrateRoot(input, parentDom, lifecycle)) {\n                mount(input, parentDom, lifecycle, {}, false);\n            }\n            root = setRoot(parentDom, input, lifecycle);\n            lifecycle.trigger();\n        }\n    }\n    else {\n        var lifecycle$1 = root.lifecycle;\n        lifecycle$1.listeners = [];\n        if (isNullOrUndef(input)) {\n            unmount(root.input, parentDom, lifecycle$1, false, false);\n            removeRoot(root);\n        }\n        else {\n            if (input.dom) {\n                input = cloneVNode(input);\n            }\n            patch(root.input, input, parentDom, lifecycle$1, {}, false, false);\n        }\n        lifecycle$1.trigger();\n        root.input = input;\n    }\n    if (root) {\n        var rootInput = root.input;\n        if (rootInput && (rootInput.flags & 28 /* Component */)) {\n            return rootInput.children;\n        }\n    }\n}\nfunction createRenderer(_parentDom) {\n    var parentDom = _parentDom || null;\n    return function renderer(lastInput, nextInput) {\n        if (!parentDom) {\n            parentDom = lastInput;\n        }\n        render(nextInput, parentDom);\n    };\n}\n\nfunction linkEvent(data, event) {\n    return { data: data, event: event };\n}\n\nif (false) {\n\tObject.freeze(EMPTY_OBJ);\n\tvar testFunc = function testFn() {};\n\twarning(\n\t\t(testFunc.name || testFunc.toString()).indexOf('testFn') !== -1,\n\t\t'It looks like you\\'re using a minified copy of the development build ' +\n\t\t'of Inferno. When deploying Inferno apps to production, make sure to use ' +\n\t\t'the production build which skips development warnings and is faster. ' +\n\t\t'See http://infernojs.org for more details.'\n\t);\n}\n\n// we duplicate it so it plays nicely with different module loading systems\nvar index = {\n\tlinkEvent: linkEvent,\n\t// core shapes\n\tcreateVNode: createVNode,\n\n\t// cloning\n\tcloneVNode: cloneVNode,\n\n\t// used to shared common items between Inferno libs\n\tNO_OP: NO_OP,\n\tEMPTY_OBJ: EMPTY_OBJ,\n\n\t// DOM\n\trender: render,\n\tfindDOMNode: findDOMNode,\n\tcreateRenderer: createRenderer,\n\toptions: options\n};\n\nexports['default'] = index;\nexports.linkEvent = linkEvent;\nexports.createVNode = createVNode;\nexports.cloneVNode = cloneVNode;\nexports.NO_OP = NO_OP;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.render = render;\nexports.findDOMNode = findDOMNode;\nexports.createRenderer = createRenderer;\nexports.options = options;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inferno__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inferno___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_inferno__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_inferno_create_element__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_inferno_create_element___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_inferno_create_element__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__acomponent__ = __webpack_require__(2);\n\n\n\n\nfunction runapp() {\n  __WEBPACK_IMPORTED_MODULE_0_inferno___default.a.render(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__acomponent__[\"a\" /* default */])(), document.getElementById('inferno'));\n}\n\n// this is only relevant when using `hot` mode with webpack\n// special thanks to Eric Clemmons: https://github.com/ericclemmons/webpack-hot-server-example\nvar reloading = document.readyState === 'complete';\nif (false) {\n  module.hot.accept(function (err) {\n    console.log('❌  HMR Error:', err);\n  });\n  if (reloading) {\n    console.log('🔁  HMR Reloading.');\n    runapp();\n  } else {\n    console.info('✅  HMR Enabled.');\n    runapp();\n  }\n} else {\n  console.info('❌  HMR Not Supported.');\n  runapp();\n}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 53199fd1ca90a52780b7","module.exports = require('./dist/inferno.node');\nmodule.exports.default = module.exports;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/inferno/inferno.js\n// module id = 0\n// module chunks = 0","module.exports = require('inferno/dist/inferno-create-element.node');\nmodule.exports.default = module.exports;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/inferno-create-element/inferno-create-element.js\n// module id = 1\n// module chunks = 0","import Inferno from 'inferno'\nimport createElement from 'inferno-create-element'\n\nvar message = 'subcomponent'\n\nfunction MyComponent(props) {\n  return createElement('div', null, message)\n}\n\nexport default MyComponent\n\n\n\n// WEBPACK FOOTER //\n// ./acomponent.js","/*!\n * inferno-create-element v1.1.1\n * (c) 2017 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('inferno')) :\n    typeof define === 'function' && define.amd ? define(['inferno'], factory) :\n    (global.Inferno = global.Inferno || {}, global.Inferno.createElement = factory(global.Inferno));\n}(this, (function (inferno) { 'use strict';\n\n// this is MUCH faster than .constructor === Array and instanceof Array\n// in Node 7 and the later versions of V8, slower in older versions though\n\nfunction isStatefulComponent(o) {\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\n}\n\n\nfunction isInvalid(obj) {\n    return isNull(obj) || obj === false || isTrue(obj) || isUndefined(obj);\n}\n\nfunction isAttrAnEvent(attr) {\n    return attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n}\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\n\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isObject(o) {\n    return typeof o === 'object';\n}\n\nvar componentHooks = {\n    onComponentWillMount: true,\n    onComponentDidMount: true,\n    onComponentWillUnmount: true,\n    onComponentShouldUpdate: true,\n    onComponentWillUpdate: true,\n    onComponentDidUpdate: true\n};\nfunction createElement$1(name, props) {\n    var _children = [], len = arguments.length - 2;\n    while ( len-- > 0 ) _children[ len ] = arguments[ len + 2 ];\n\n    if (isInvalid(name) || isObject(name)) {\n        throw new Error('Inferno Error: createElement() name parameter cannot be undefined, null, false or true, It must be a string, class or function.');\n    }\n    var children = _children;\n    var ref = null;\n    var key = null;\n    var events = null;\n    var flags = 0;\n    if (_children) {\n        if (_children.length === 1) {\n            children = _children[0];\n        }\n        else if (_children.length === 0) {\n            children = undefined;\n        }\n    }\n    if (isString(name)) {\n        flags = 2 /* HtmlElement */;\n        switch (name) {\n            case 'svg':\n                flags = 128 /* SvgElement */;\n                break;\n            case 'input':\n                flags = 512 /* InputElement */;\n                break;\n            case 'textarea':\n                flags = 1024 /* TextareaElement */;\n                break;\n            case 'select':\n                flags = 2048 /* SelectElement */;\n                break;\n            default:\n        }\n        for (var prop in props) {\n            if (prop === 'key') {\n                key = props.key;\n                delete props.key;\n            }\n            else if (prop === 'children' && isUndefined(children)) {\n                children = props.children; // always favour children args, default to props\n            }\n            else if (prop === 'ref') {\n                ref = props.ref;\n            }\n            else if (isAttrAnEvent(prop)) {\n                if (!events) {\n                    events = {};\n                }\n                events[prop] = props[prop];\n                delete props[prop];\n            }\n        }\n    }\n    else {\n        flags = isStatefulComponent(name) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;\n        if (!isUndefined(children)) {\n            if (!props) {\n                props = {};\n            }\n            props.children = children;\n            children = null;\n        }\n        for (var prop$1 in props) {\n            if (componentHooks[prop$1]) {\n                if (!ref) {\n                    ref = {};\n                }\n                ref[prop$1] = props[prop$1];\n            }\n            else if (prop$1 === 'key') {\n                key = props.key;\n                delete props.key;\n            }\n        }\n    }\n    return inferno.createVNode(flags, name, props, children, events, key, ref);\n}\n\nreturn createElement$1;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/inferno/dist/inferno-create-element.node.js\n// module id = 3\n// module chunks = 0","/*!\n * inferno v1.1.1\n * (c) 2017 Dominic Gannaway\n * Released under the MIT License.\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Inferno = global.Inferno || {})));\n}(this, (function (exports) { 'use strict';\n\nvar NO_OP = '$NO_OP';\nvar ERROR_MSG = 'a runtime error occured! Use Inferno in development environment to find the error.';\nvar isBrowser = typeof window !== 'undefined' && window.document;\n\n// this is MUCH faster than .constructor === Array and instanceof Array\n// in Node 7 and the later versions of V8, slower in older versions though\nvar isArray = Array.isArray;\nfunction isStatefulComponent(o) {\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\n}\nfunction isStringOrNumber(obj) {\n    var type = typeof obj;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(obj) {\n    return isUndefined(obj) || isNull(obj);\n}\nfunction isInvalid(obj) {\n    return isNull(obj) || obj === false || isTrue(obj) || isUndefined(obj);\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nfunction isAttrAnEvent(attr) {\n    return attr[0] === 'o' && attr[1] === 'n' && attr.length > 3;\n}\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\nfunction isNumber(obj) {\n    return typeof obj === 'number';\n}\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isObject(o) {\n    return typeof o === 'object';\n}\nfunction throwError(message) {\n    if (!message) {\n        message = ERROR_MSG;\n    }\n    throw new Error((\"Inferno Error: \" + message));\n}\nfunction warning(condition, message) {\n    if (!condition) {\n        console.error(message);\n    }\n}\nvar EMPTY_OBJ = {};\n\nfunction applyKey(key, vNode) {\n    vNode.key = key;\n    return vNode;\n}\nfunction applyKeyIfMissing(key, vNode) {\n    if (isNumber(key)) {\n        key = \".\" + key;\n    }\n    if (isNull(vNode.key) || vNode.key[0] === '.') {\n        return applyKey(key, vNode);\n    }\n    return vNode;\n}\nfunction applyKeyPrefix(key, vNode) {\n    vNode.key = key + vNode.key;\n    return vNode;\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (; index < nodes.length; index++) {\n        var n = nodes[index];\n        var key = currentKey + \".\" + index;\n        if (!isInvalid(n)) {\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, key);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n);\n                }\n                else if (isVNode(n) && n.dom || (n.key && n.key[0] === '.')) {\n                    n = cloneVNode(n);\n                }\n                if (isNull(n.key) || n.key[0] === '.') {\n                    n = applyKey(key, n);\n                }\n                else {\n                    n = applyKeyPrefix(currentKey, n);\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction normalizeVNodes(nodes) {\n    var newNodes;\n    // we assign $ which basically means we've flagged this array for future note\n    // if it comes back again, we need to clone it, as people are using it\n    // in an immutable way\n    // tslint:disable\n    if (nodes['$']) {\n        nodes = nodes.slice();\n    }\n    else {\n        nodes['$'] = true;\n    }\n    // tslint:enable\n    for (var i = 0; i < nodes.length; i++) {\n        var n = nodes[i];\n        if (isInvalid(n) || isArray(n)) {\n            var result = (newNodes || nodes).slice(0, i);\n            _normalizeVNodes(nodes, result, i, \"\");\n            return result;\n        }\n        else if (isStringOrNumber(n)) {\n            if (!newNodes) {\n                newNodes = nodes.slice(0, i);\n            }\n            newNodes.push(applyKeyIfMissing(i, createTextVNode(n)));\n        }\n        else if ((isVNode(n) && n.dom) || (isNull(n.key) && !(n.flags & 64 /* HasNonKeyedChildren */))) {\n            if (!newNodes) {\n                newNodes = nodes.slice(0, i);\n            }\n            newNodes.push(applyKeyIfMissing(i, cloneVNode(n)));\n        }\n        else if (newNodes) {\n            newNodes.push(applyKeyIfMissing(i, cloneVNode(n)));\n        }\n    }\n    return newNodes || nodes;\n}\nfunction normalizeChildren(children) {\n    if (isArray(children)) {\n        return normalizeVNodes(children);\n    }\n    else if (isVNode(children) && children.dom) {\n        return cloneVNode(children);\n    }\n    return children;\n}\nfunction normalizeProps(vNode, props, children) {\n    if (!(vNode.flags & 28 /* Component */) && isNullOrUndef(children) && !isNullOrUndef(props.children)) {\n        vNode.children = props.children;\n    }\n    if (props.ref) {\n        vNode.ref = props.ref;\n        delete props.ref;\n    }\n    if (props.events) {\n        vNode.events = props.events;\n    }\n    if (!isNullOrUndef(props.key)) {\n        vNode.key = props.key;\n        delete props.key;\n    }\n}\nfunction copyPropsTo(copyFrom, copyTo) {\n    for (var prop in copyFrom) {\n        if (isUndefined(copyTo[prop])) {\n            copyTo[prop] = copyFrom[prop];\n        }\n    }\n}\nfunction normalizeElement(type, vNode) {\n    if (type === 'svg') {\n        vNode.flags = 128 /* SvgElement */;\n    }\n    else if (type === 'input') {\n        vNode.flags = 512 /* InputElement */;\n    }\n    else if (type === 'select') {\n        vNode.flags = 2048 /* SelectElement */;\n    }\n    else if (type === 'textarea') {\n        vNode.flags = 1024 /* TextareaElement */;\n    }\n    else if (type === 'media') {\n        vNode.flags = 256 /* MediaElement */;\n    }\n    else {\n        vNode.flags = 2 /* HtmlElement */;\n    }\n}\nfunction normalize(vNode) {\n    var props = vNode.props;\n    var hasProps = !isNull(props);\n    var type = vNode.type;\n    var children = vNode.children;\n    // convert a wrongly created type back to element\n    if (isString(type) && (vNode.flags & 28 /* Component */)) {\n        normalizeElement(type, vNode);\n        if (hasProps && props.children) {\n            vNode.children = props.children;\n            children = props.children;\n        }\n    }\n    if (hasProps) {\n        normalizeProps(vNode, props, children);\n    }\n    if (!isInvalid(children)) {\n        vNode.children = normalizeChildren(children);\n    }\n    if (hasProps && !isInvalid(props.children)) {\n        props.children = normalizeChildren(props.children);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        // This code will be stripped out from production CODE\n        // It will help users to track errors in their applications.\n        function verifyKeys(vNodes) {\n            var keyValues = vNodes.map(function (vnode) { return vnode.key; });\n            keyValues.some(function (item, idx) {\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\n                warning(!hasDuplicate, 'Infreno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:' + item);\n                return hasDuplicate;\n            });\n        }\n        if (vNode.children && Array.isArray(vNode.children)) {\n            verifyKeys(vNode.children);\n        }\n    }\n}\n\nvar options = {\n    recyclingEnabled: true,\n    findDOMNodeEnabled: false,\n    roots: null,\n    createVNode: null,\n    beforeRender: null,\n    afterRender: null,\n    afterMount: null,\n    afterUpdate: null,\n    beforeUnmount: null\n};\n\nfunction createVNode(flags, type, props, children, events, key, ref, noNormalise) {\n    if (flags & 16 /* ComponentUnknown */) {\n        flags = isStatefulComponent(type) ? 4 /* ComponentClass */ : 8 /* ComponentFunction */;\n    }\n    var vNode = {\n        children: isUndefined(children) ? null : children,\n        dom: null,\n        events: events || null,\n        flags: flags,\n        key: isUndefined(key) ? null : key,\n        props: props || null,\n        ref: ref || null,\n        type: type\n    };\n    if (!noNormalise) {\n        normalize(vNode);\n    }\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    return vNode;\n}\nfunction cloneVNode(vNodeToClone, props) {\n    var _children = [], len = arguments.length - 2;\n    while ( len-- > 0 ) _children[ len ] = arguments[ len + 2 ];\n\n    var children = _children;\n    if (_children.length > 0 && !isNull(_children[0])) {\n        if (!props) {\n            props = {};\n        }\n        if (_children.length === 1) {\n            children = _children[0];\n        }\n        if (isUndefined(props.children)) {\n            props.children = children;\n        }\n        else {\n            if (isArray(children)) {\n                if (isArray(props.children)) {\n                    props.children = props.children.concat(children);\n                }\n                else {\n                    props.children = [props.children].concat(children);\n                }\n            }\n            else {\n                if (isArray(props.children)) {\n                    props.children.push(children);\n                }\n                else {\n                    props.children = [props.children];\n                    props.children.push(children);\n                }\n            }\n        }\n    }\n    children = null;\n    var newVNode;\n    if (isArray(vNodeToClone)) {\n        var tmpArray = [];\n        for (var i = 0; i < vNodeToClone.length; i++) {\n            tmpArray.push(cloneVNode(vNodeToClone[i]));\n        }\n        newVNode = tmpArray;\n    }\n    else {\n        var flags = vNodeToClone.flags;\n        var events = vNodeToClone.events || (props && props.events) || null;\n        var key = !isNullOrUndef(vNodeToClone.key) ? vNodeToClone.key : (props ? props.key : null);\n        var ref = vNodeToClone.ref || (props ? props.ref : null);\n        if (flags & 28 /* Component */) {\n            newVNode = createVNode(flags, vNodeToClone.type, Object.assign({}, vNodeToClone.props, props), null, events, key, ref, true);\n            var newProps = newVNode.props;\n            if (newProps) {\n                var newChildren = newProps.children;\n                // we need to also clone component children that are in props\n                // as the children may also have been hoisted\n                if (newChildren) {\n                    if (isArray(newChildren)) {\n                        for (var i$1 = 0; i$1 < newChildren.length; i$1++) {\n                            var child = newChildren[i$1];\n                            if (!isInvalid(child) && isVNode(child)) {\n                                newProps.children[i$1] = cloneVNode(child);\n                            }\n                        }\n                    }\n                    else if (isVNode(newChildren)) {\n                        newProps.children = cloneVNode(newChildren);\n                    }\n                }\n            }\n            newVNode.children = null;\n        }\n        else if (flags & 3970 /* Element */) {\n            children = (props && props.children) || vNodeToClone.children;\n            newVNode = createVNode(flags, vNodeToClone.type, Object.assign({}, vNodeToClone.props, props), children, events, key, ref, !children);\n        }\n        else if (flags & 1 /* Text */) {\n            newVNode = createTextVNode(vNodeToClone.children);\n        }\n    }\n    return newVNode;\n}\nfunction createVoidVNode() {\n    return createVNode(4096 /* Void */);\n}\nfunction createTextVNode(text) {\n    return createVNode(1 /* Text */, null, null, text, null, null, null, true);\n}\nfunction isVNode(o) {\n    return !!o.flags;\n}\n\nvar Lifecycle = function Lifecycle() {\n    this.listeners = [];\n    this.fastUnmount = true;\n};\nLifecycle.prototype.addListener = function addListener (callback) {\n    this.listeners.push(callback);\n};\nLifecycle.prototype.trigger = function trigger () {\n        var this$1 = this;\n\n    for (var i = 0; i < this.listeners.length; i++) {\n        this$1.listeners[i]();\n    }\n};\n\nfunction constructDefaults(string, object, value) {\n    /* eslint no-return-assign: 0 */\n    string.split(',').forEach(function (i) { return object[i] = value; });\n}\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar svgNS = 'http://www.w3.org/2000/svg';\nvar strictProps = {};\nvar booleanProps = {};\nvar namespaces = {};\nvar isUnitlessNumber = {};\nvar skipProps = {};\nvar dehyphenProps = {\n    httpEquiv: 'http-equiv',\n    acceptCharset: 'accept-charset'\n};\nvar probablyKebabProps = /^(accentH|arabicF|capH|font[FSVW]|glyph[NO]|horiz[AO]|panose1|renderingI|strikethrough[PT]|underline[PT]|v[AHIM]|vert[AO]|xH|alignmentB|baselineS|clip[PR]|color[IPR]|dominantB|enableB|fill[OR]|flood[COF]|imageR|letterS|lightingC|marker[EMS]|pointerE|shapeR|stop[CO]|stroke[DLMOW]|text[ADR]|unicodeB|wordS|writingM).*/;\nfunction kebabize(str, smallLetter, largeLetter) {\n    return (smallLetter + \"-\" + (largeLetter.toLowerCase()));\n}\nvar delegatedProps = {};\nconstructDefaults('xlink:href,xlink:arcrole,xlink:actuate,xlink:role,xlink:titlef,xlink:type', namespaces, xlinkNS);\nconstructDefaults('xml:base,xml:lang,xml:space', namespaces, xmlNS);\nconstructDefaults('volume,defaultValue,defaultChecked', strictProps, true);\nconstructDefaults('children,ref,key,selected,checked,value,multiple', skipProps, true);\nconstructDefaults('onClick,onMouseDown,onMouseUp,onMouseMove,onSubmit,onDblClick,onKeyDown,onKeyUp,onKeyPress', delegatedProps, true);\nconstructDefaults('muted,scoped,loop,open,checked,default,capture,disabled,readOnly,required,autoplay,controls,seamless,reversed,allowfullscreen,novalidate', booleanProps, true);\nconstructDefaults('animationIterationCount,borderImageOutset,borderImageSlice,borderImageWidth,boxFlex,boxFlexGroup,boxOrdinalGroup,columnCount,flex,flexGrow,flexPositive,flexShrink,flexNegative,flexOrder,gridRow,gridColumn,fontWeight,lineClamp,lineHeight,opacity,order,orphans,tabSize,widows,zIndex,zoom,fillOpacity,floodOpacity,stopOpacity,strokeDasharray,strokeDashoffset,strokeMiterlimit,strokeOpacity,strokeWidth,', isUnitlessNumber, true);\n\nvar isiOS = isBrowser && !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform);\nvar delegatedEvents = new Map();\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\n    var delegatedRoots = delegatedEvents.get(name);\n    if (nextEvent) {\n        if (!delegatedRoots) {\n            delegatedRoots = { items: new Map(), count: 0, docEvent: null };\n            var docEvent = attachEventToDocument(name, delegatedRoots);\n            delegatedRoots.docEvent = docEvent;\n            delegatedEvents.set(name, delegatedRoots);\n        }\n        if (!lastEvent) {\n            delegatedRoots.count++;\n            if (isiOS && name === 'onClick') {\n                trapClickOnNonInteractiveElement(dom);\n            }\n        }\n        delegatedRoots.items.set(dom, nextEvent);\n    }\n    else if (delegatedRoots) {\n        if (delegatedRoots.items.has(dom)) {\n            delegatedRoots.count--;\n            delegatedRoots.items.delete(dom);\n            if (delegatedRoots.count === 0) {\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\n                delegatedEvents.delete(name);\n            }\n        }\n    }\n}\nfunction dispatchEvent(event, dom, items, count, eventData) {\n    var eventsToTrigger = items.get(dom);\n    if (eventsToTrigger) {\n        count--;\n        // linkEvent object\n        eventData.dom = dom;\n        if (eventsToTrigger.event) {\n            eventsToTrigger.event(eventsToTrigger.data, event);\n        }\n        else {\n            eventsToTrigger(event);\n        }\n        if (eventData.stopPropagation) {\n            return;\n        }\n    }\n    var parentDom = dom.parentNode;\n    if (count > 0 && (parentDom || parentDom === document.body)) {\n        dispatchEvent(event, parentDom, items, count, eventData);\n    }\n}\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction attachEventToDocument(name, delegatedRoots) {\n    var docEvent = function (event) {\n        var eventData = {\n            stopPropagation: false,\n            dom: document\n        };\n        // we have to do this as some browsers recycle the same Event between calls\n        // so we need to make the property configurable\n        Object.defineProperty(event, 'currentTarget', {\n            configurable: true,\n            get: function get() {\n                return eventData.dom;\n            }\n        });\n        event.stopPropagation = function () {\n            eventData.stopPropagation = true;\n        };\n        var count = delegatedRoots.count;\n        if (count > 0) {\n            dispatchEvent(event, event.target, delegatedRoots.items, count, eventData);\n        }\n    };\n    document.addEventListener(normalizeEventName(name), docEvent);\n    return docEvent;\n}\nfunction emptyFn() { }\nfunction trapClickOnNonInteractiveElement(dom) {\n    // Mobile Safari does not fire properly bubble click events on\n    // non-interactive elements, which means delegated click listeners do not\n    // fire. The workaround for this bug involves attaching an empty click\n    // listener on the target node.\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n    // Just set it using the onclick property so that we don't have to manage any\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\n    // removed.\n    // TODO: Only do this for the relevant Safaris maybe?\n    dom.onclick = emptyFn;\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nfunction isControlled(props) {\n    var usesChecked = isCheckedType(props.type);\n    return usesChecked ? !isNullOrUndef(props.checked) : !isNullOrUndef(props.value);\n}\nfunction onTextInputChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onInput) {\n        var event = events.onInput;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.oninput) {\n        events.oninput(e);\n    }\n    // the user may have updated the vNode from the above onInput events\n    // so we need to get it from the context of `this` again\n    applyValue(this.vNode, dom);\n}\nfunction wrappedOnChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var event = events.onChange;\n    if (event.event) {\n        event.event(event.data, e);\n    }\n    else {\n        event(e);\n    }\n}\nfunction onCheckboxChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onClick) {\n        var event = events.onClick;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.onclick) {\n        events.onclick(e);\n    }\n    // the user may have updated the vNode from the above onClick events\n    // so we need to get it from the context of `this` again\n    applyValue(this.vNode, dom);\n}\nfunction handleAssociatedRadioInputs(name) {\n    var inputs = document.querySelectorAll((\"input[type=\\\"radio\\\"][name=\\\"\" + name + \"\\\"]\"));\n    [].forEach.call(inputs, function (dom) {\n        var inputWrapper = wrappers.get(dom);\n        if (inputWrapper) {\n            var props = inputWrapper.vNode.props;\n            if (props) {\n                dom.checked = inputWrapper.vNode.props.checked;\n            }\n        }\n    });\n}\nfunction processInput(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue(vNode, dom);\n    if (isControlled(props)) {\n        var inputWrapper = wrappers.get(dom);\n        if (!inputWrapper) {\n            inputWrapper = {\n                vNode: vNode\n            };\n            if (isCheckedType(props.type)) {\n                dom.onclick = onCheckboxChange.bind(inputWrapper);\n                dom.onclick.wrapped = true;\n            }\n            else {\n                dom.oninput = onTextInputChange.bind(inputWrapper);\n                dom.oninput.wrapped = true;\n            }\n            if (props.onChange) {\n                dom.onchange = wrappedOnChange.bind(inputWrapper);\n                dom.onchange.wrapped = true;\n            }\n            wrappers.set(dom, inputWrapper);\n        }\n        inputWrapper.vNode = vNode;\n    }\n}\nfunction applyValue(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    var type = props.type;\n    var value = props.value;\n    var checked = props.checked;\n    var multiple = props.multiple;\n    if (type && type !== dom.type) {\n        dom.type = type;\n    }\n    if (multiple && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (isCheckedType(type)) {\n        if (!isNullOrUndef(value)) {\n            dom.value = value;\n        }\n        dom.checked = checked;\n        if (type === 'radio' && props.name) {\n            handleAssociatedRadioInputs(props.name);\n        }\n    }\n    else {\n        if (!isNullOrUndef(value) && dom.value !== value) {\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction isControlled$1(props) {\n    return !isNullOrUndef(props.value);\n}\nfunction updateChildOptionGroup(vNode, value) {\n    var type = vNode.type;\n    if (type === 'optgroup') {\n        var children = vNode.children;\n        if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n                updateChildOption(children[i], value);\n            }\n        }\n        else if (isVNode(children)) {\n            updateChildOption(children, value);\n        }\n    }\n    else {\n        updateChildOption(vNode, value);\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if ((isArray(value) && value.indexOf(props.value) !== -1) || props.value === value) {\n        dom.selected = true;\n    }\n    else {\n        dom.selected = props.selected || false;\n    }\n}\nfunction onSelectChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onChange) {\n        var event = events.onChange;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.onchange) {\n        events.onchange(e);\n    }\n    // the user may have updated the vNode from the above onChange events\n    // so we need to get it from the context of `this` again\n    applyValue$1(this.vNode, dom);\n}\nfunction processSelect(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue$1(vNode, dom);\n    if (isControlled$1(props)) {\n        var selectWrapper = wrappers.get(dom);\n        if (!selectWrapper) {\n            selectWrapper = {\n                vNode: vNode\n            };\n            dom.onchange = onSelectChange.bind(selectWrapper);\n            dom.onchange.wrapped = true;\n            wrappers.set(dom, selectWrapper);\n        }\n        selectWrapper.vNode = vNode;\n    }\n}\nfunction applyValue$1(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    if (props.multiple !== dom.multiple) {\n        dom.multiple = props.multiple;\n    }\n    var children = vNode.children;\n    var value = props.value;\n    if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n            updateChildOptionGroup(children[i], value);\n        }\n    }\n    else if (isVNode(children)) {\n        updateChildOptionGroup(children, value);\n    }\n}\n\nfunction isControlled$2(props) {\n    return !isNullOrUndef(props.value);\n}\nfunction wrappedOnChange$1(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var event = events.onChange;\n    if (event.event) {\n        event.event(event.data, e);\n    }\n    else {\n        event(e);\n    }\n}\nfunction onTextareaInputChange(e) {\n    var vNode = this.vNode;\n    var events = vNode.events || EMPTY_OBJ;\n    var dom = vNode.dom;\n    if (events.onInput) {\n        var event = events.onInput;\n        if (event.event) {\n            event.event(event.data, e);\n        }\n        else {\n            event(e);\n        }\n    }\n    else if (events.oninput) {\n        events.oninput(e);\n    }\n    // the user may have updated the vNode from the above onInput events\n    // so we need to get it from the context of `this` again\n    applyValue$2(this.vNode, dom);\n}\nfunction processTextarea(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    applyValue$2(vNode, dom);\n    var textareaWrapper = wrappers.get(dom);\n    if (isControlled$2(props)) {\n        if (!textareaWrapper) {\n            textareaWrapper = {\n                vNode: vNode\n            };\n            dom.oninput = onTextareaInputChange.bind(textareaWrapper);\n            dom.oninput.wrapped = true;\n            if (props.onChange) {\n                dom.onchange = wrappedOnChange$1.bind(textareaWrapper);\n                dom.onchange.wrapped = true;\n            }\n            wrappers.set(dom, textareaWrapper);\n        }\n        textareaWrapper.vNode = vNode;\n    }\n}\nfunction applyValue$2(vNode, dom) {\n    var props = vNode.props || EMPTY_OBJ;\n    var value = props.value;\n    if (dom.value !== value) {\n        if (!isNullOrUndef(value)) {\n            dom.value = value;\n        }\n    }\n}\n\nvar wrappers = new Map();\nfunction processElement(flags, vNode, dom) {\n    if (flags & 512 /* InputElement */) {\n        processInput(vNode, dom);\n    }\n    else if (flags & 2048 /* SelectElement */) {\n        processSelect(vNode, dom);\n    }\n    else if (flags & 1024 /* TextareaElement */) {\n        processTextarea(vNode, dom);\n    }\n}\n\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var flags = vNode.flags;\n    if (flags & 28 /* Component */) {\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\n    }\n    else if (flags & 3970 /* Element */) {\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\n    }\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\n        unmountVoidOrText(vNode, parentDom);\n    }\n}\nfunction unmountVoidOrText(vNode, parentDom) {\n    if (parentDom) {\n        removeChild(parentDom, vNode.dom);\n    }\n}\nvar alreadyUnmounted = new WeakMap();\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var instance = vNode.children;\n    var flags = vNode.flags;\n    var isStatefulComponent$$1 = flags & 4;\n    var ref = vNode.ref;\n    var dom = vNode.dom;\n    if (alreadyUnmounted.has(vNode) && !isRecycling && !parentDom) {\n        return;\n    }\n    alreadyUnmounted.set(vNode);\n    if (!isRecycling) {\n        if (isStatefulComponent$$1) {\n            if (!instance._unmounted) {\n                instance._ignoreSetState = true;\n                options.beforeUnmount && options.beforeUnmount(vNode);\n                instance.componentWillUnmount && instance.componentWillUnmount();\n                if (ref && !isRecycling) {\n                    ref(null);\n                }\n                instance._unmounted = true;\n                options.findDOMNodeEnabled && componentToDOMNodeMap.delete(instance);\n                var subLifecycle = instance._lifecycle;\n                if (!subLifecycle.fastUnmount) {\n                    unmount(instance._lastInput, null, subLifecycle, false, isRecycling);\n                }\n            }\n        }\n        else {\n            if (!isNullOrUndef(ref)) {\n                if (!isNullOrUndef(ref.onComponentWillUnmount)) {\n                    ref.onComponentWillUnmount(dom);\n                }\n            }\n            if (!lifecycle.fastUnmount) {\n                unmount(instance, null, lifecycle, false, isRecycling);\n            }\n        }\n    }\n    if (parentDom) {\n        var lastInput = instance._lastInput;\n        if (isNullOrUndef(lastInput)) {\n            lastInput = instance;\n        }\n        removeChild(parentDom, dom);\n    }\n    if (options.recyclingEnabled && !isStatefulComponent$$1 && (parentDom || canRecycle)) {\n        poolComponent(vNode);\n    }\n}\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\n    var dom = vNode.dom;\n    var ref = vNode.ref;\n    var events = vNode.events;\n    if (alreadyUnmounted.has(vNode) && !isRecycling && !parentDom) {\n        return;\n    }\n    alreadyUnmounted.set(vNode);\n    if (!lifecycle.fastUnmount) {\n        if (ref && !isRecycling) {\n            unmountRef(ref);\n        }\n        var children = vNode.children;\n        if (!isNullOrUndef(children)) {\n            unmountChildren$1(children, lifecycle, isRecycling);\n        }\n    }\n    if (!isNull(events)) {\n        for (var name in events) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, events[name], null, dom, lifecycle);\n            events[name] = null;\n        }\n    }\n    if (parentDom) {\n        removeChild(parentDom, dom);\n    }\n    if (options.recyclingEnabled && (parentDom || canRecycle)) {\n        poolElement(vNode);\n    }\n}\nfunction unmountChildren$1(children, lifecycle, isRecycling) {\n    if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (!isInvalid(child) && isObject(child)) {\n                unmount(child, null, lifecycle, false, isRecycling);\n            }\n        }\n    }\n    else if (isObject(children)) {\n        unmount(children, null, lifecycle, false, isRecycling);\n    }\n}\nfunction unmountRef(ref) {\n    if (isFunction(ref)) {\n        ref(null);\n    }\n    else {\n        if (isInvalid(ref)) {\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        throwError();\n    }\n}\n\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    if (lastVNode !== nextVNode) {\n        var lastFlags = lastVNode.flags;\n        var nextFlags = nextVNode.flags;\n        if (nextFlags & 28 /* Component */) {\n            if (lastFlags & 28 /* Component */) {\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, nextFlags & 4 /* ComponentClass */, isRecycling);\n            }\n            else {\n                replaceVNode(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, nextFlags & 4 /* ComponentClass */), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 3970 /* Element */) {\n            if (lastFlags & 3970 /* Element */) {\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n            }\n            else {\n                replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 1 /* Text */) {\n            if (lastFlags & 1 /* Text */) {\n                patchText(lastVNode, nextVNode);\n            }\n            else {\n                replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else if (nextFlags & 4096 /* Void */) {\n            if (lastFlags & 4096 /* Void */) {\n                patchVoid(lastVNode, nextVNode);\n            }\n            else {\n                replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\n            }\n        }\n        else {\n            // Error case: mount new one replacing old one\n            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n        }\n    }\n}\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\n    if (isVNode(children)) {\n        unmount(children, dom, lifecycle, true, isRecycling);\n    }\n    else if (isArray(children)) {\n        removeAllChildren(dom, children, lifecycle, isRecycling);\n    }\n    else {\n        dom.textContent = '';\n    }\n}\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    var nextTag = nextVNode.type;\n    var lastTag = lastVNode.type;\n    if (lastTag !== nextTag) {\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n    }\n    else {\n        var dom = lastVNode.dom;\n        var lastProps = lastVNode.props;\n        var nextProps = nextVNode.props;\n        var lastChildren = lastVNode.children;\n        var nextChildren = nextVNode.children;\n        var lastFlags = lastVNode.flags;\n        var nextFlags = nextVNode.flags;\n        var lastRef = lastVNode.ref;\n        var nextRef = nextVNode.ref;\n        var lastEvents = lastVNode.events;\n        var nextEvents = nextVNode.events;\n        nextVNode.dom = dom;\n        if (isSVG || (nextFlags & 128 /* SvgElement */)) {\n            isSVG = true;\n        }\n        if (lastChildren !== nextChildren) {\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        if (!(nextFlags & 2 /* HtmlElement */)) {\n            processElement(nextFlags, nextVNode, dom);\n        }\n        if (lastProps !== nextProps) {\n            patchProps(lastProps, nextProps, dom, lifecycle, context, isSVG);\n        }\n        if (lastEvents !== nextEvents) {\n            patchEvents(lastEvents, nextEvents, dom, lifecycle);\n        }\n        if (nextRef) {\n            if (lastRef !== nextRef || isRecycling) {\n                mountRef(dom, nextRef, lifecycle);\n            }\n        }\n    }\n}\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\n    var patchArray = false;\n    var patchKeyed = false;\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\n        patchArray = true;\n    }\n    else if ((lastFlags & 32 /* HasKeyedChildren */) && (nextFlags & 32 /* HasKeyedChildren */)) {\n        patchKeyed = true;\n        patchArray = true;\n    }\n    else if (isInvalid(nextChildren)) {\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n    }\n    else if (isInvalid(lastChildren)) {\n        if (isStringOrNumber(nextChildren)) {\n            setTextContent(dom, nextChildren);\n        }\n        else {\n            if (isArray(nextChildren)) {\n                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\n            }\n            else {\n                mount(nextChildren, dom, lifecycle, context, isSVG);\n            }\n        }\n    }\n    else if (isStringOrNumber(nextChildren)) {\n        if (isStringOrNumber(lastChildren)) {\n            updateTextContent(dom, nextChildren);\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            setTextContent(dom, nextChildren);\n        }\n    }\n    else if (isArray(nextChildren)) {\n        if (isArray(lastChildren)) {\n            patchArray = true;\n            if (isKeyed(lastChildren, nextChildren)) {\n                patchKeyed = true;\n            }\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\n        }\n    }\n    else if (isArray(lastChildren)) {\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\n        mount(nextChildren, dom, lifecycle, context, isSVG);\n    }\n    else if (isVNode(nextChildren)) {\n        if (isVNode(lastChildren)) {\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\n            mount(nextChildren, dom, lifecycle, context, isSVG);\n        }\n    } /* else if (isVNode(lastChildren)) {\n        // TODO: One test hits this line when passing invalid children what should be done?\n        // debugger;\n    } else {\n        // debugger;\n    }*/\n    if (patchArray) {\n        if (patchKeyed) {\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\n        }\n    }\n}\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\n    var lastType = lastVNode.type;\n    var nextType = nextVNode.type;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var lastKey = lastVNode.key;\n    var nextKey = nextVNode.key;\n    var defaultProps = nextType.defaultProps;\n    if (!isUndefined(defaultProps)) {\n        copyPropsTo(defaultProps, nextProps);\n        nextVNode.props = nextProps;\n    }\n    if (lastType !== nextType) {\n        if (isClass) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n        }\n        else {\n            var lastInput = lastVNode.children._lastInput || lastVNode.children;\n            var nextInput = createFunctionalComponentInput(nextVNode, nextType, nextProps, context);\n            unmount(lastVNode, null, lifecycle, false, isRecycling);\n            patch(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling);\n            var dom = nextVNode.dom = nextInput.dom;\n            nextVNode.children = nextInput;\n            mountFunctionalComponentCallbacks(nextVNode.ref, dom, lifecycle);\n        }\n    }\n    else {\n        if (isClass) {\n            if (lastKey !== nextKey) {\n                replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\n                return false;\n            }\n            var instance = lastVNode.children;\n            if (instance._unmounted) {\n                if (isNull(parentDom)) {\n                    return true;\n                }\n                replaceChild(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, nextVNode.flags & 4 /* ComponentClass */), lastVNode.dom);\n            }\n            else {\n                var lastState = instance.state;\n                var nextState = instance.state;\n                var lastProps = instance.props;\n                var childContext = instance.getChildContext();\n                nextVNode.children = instance;\n                instance._isSVG = isSVG;\n                if (!isNullOrUndef(childContext)) {\n                    childContext = Object.assign({}, context, childContext);\n                }\n                else {\n                    childContext = context;\n                }\n                var lastInput$1 = instance._lastInput;\n                var nextInput$1 = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\n                var didUpdate = true;\n                instance._childContext = childContext;\n                if (isInvalid(nextInput$1)) {\n                    nextInput$1 = createVoidVNode();\n                }\n                else if (nextInput$1 === NO_OP) {\n                    nextInput$1 = lastInput$1;\n                    didUpdate = false;\n                }\n                else if (isStringOrNumber(nextInput$1)) {\n                    nextInput$1 = createTextVNode(nextInput$1);\n                }\n                else if (isArray(nextInput$1)) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n                    }\n                    throwError();\n                }\n                else if (isObject(nextInput$1) && nextInput$1.dom) {\n                    nextInput$1 = cloneVNode(nextInput$1);\n                }\n                if (nextInput$1.flags & 28 /* Component */) {\n                    nextInput$1.parentVNode = nextVNode;\n                }\n                else if (lastInput$1.flags & 28 /* Component */) {\n                    lastInput$1.parentVNode = nextVNode;\n                }\n                instance._lastInput = nextInput$1;\n                instance._vNode = nextVNode;\n                if (didUpdate) {\n                    var fastUnmount = lifecycle.fastUnmount;\n                    var subLifecycle = instance._lifecycle;\n                    lifecycle.fastUnmount = subLifecycle.fastUnmount;\n                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, childContext, isSVG, isRecycling);\n                    subLifecycle.fastUnmount = lifecycle.fastUnmount;\n                    lifecycle.fastUnmount = fastUnmount;\n                    instance.componentDidUpdate(lastProps, lastState);\n                    options.afterUpdate && options.afterUpdate(nextVNode);\n                    options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, nextInput$1.dom);\n                }\n                nextVNode.dom = nextInput$1.dom;\n            }\n        }\n        else {\n            var shouldUpdate = true;\n            var lastProps$1 = lastVNode.props;\n            var nextHooks = nextVNode.ref;\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\n            var lastInput$2 = lastVNode.children;\n            var nextInput$2 = lastInput$2;\n            nextVNode.dom = lastVNode.dom;\n            nextVNode.children = lastInput$2;\n            if (lastKey !== nextKey) {\n                shouldUpdate = true;\n            }\n            else {\n                if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);\n                }\n            }\n            if (shouldUpdate !== false) {\n                if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentWillUpdate)) {\n                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);\n                }\n                nextInput$2 = nextType(nextProps, context);\n                if (isInvalid(nextInput$2)) {\n                    nextInput$2 = createVoidVNode();\n                }\n                else if (isStringOrNumber(nextInput$2) && nextInput$2 !== NO_OP) {\n                    nextInput$2 = createTextVNode(nextInput$2);\n                }\n                else if (isArray(nextInput$2)) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n                    }\n                    throwError();\n                }\n                else if (isObject(nextInput$2) && nextInput$2.dom) {\n                    nextInput$2 = cloneVNode(nextInput$2);\n                }\n                if (nextInput$2 !== NO_OP) {\n                    patch(lastInput$2, nextInput$2, parentDom, lifecycle, context, isSVG, isRecycling);\n                    nextVNode.children = nextInput$2;\n                    if (nextHooksDefined && !isNullOrUndef(nextHooks.onComponentDidUpdate)) {\n                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);\n                    }\n                    nextVNode.dom = nextInput$2.dom;\n                }\n            }\n            if (nextInput$2.flags & 28 /* Component */) {\n                nextInput$2.parentVNode = nextVNode;\n            }\n            else if (lastInput$2.flags & 28 /* Component */) {\n                lastInput$2.parentVNode = nextVNode;\n            }\n        }\n    }\n    return false;\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = lastVNode.dom;\n    nextVNode.dom = dom;\n    if (lastVNode.children !== nextText) {\n        dom.nodeValue = nextText;\n    }\n}\nfunction patchVoid(lastVNode, nextVNode) {\n    nextVNode.dom = lastVNode.dom;\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\n    var lastChildrenLength = lastChildren.length;\n    var nextChildrenLength = nextChildren.length;\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    for (; i < commonLength; i++) {\n        var nextChild = nextChildren[i];\n        if (nextChild.dom) {\n            nextChild = nextChildren[i] = cloneVNode(nextChild);\n        }\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; i++) {\n            var nextChild$1 = nextChildren[i];\n            if (nextChild$1.dom) {\n                nextChild$1 = nextChildren[i] = cloneVNode(nextChild$1);\n            }\n            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));\n        }\n    }\n    else if (nextChildrenLength === 0) {\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; i++) {\n            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\n    var aLength = a.length;\n    var bLength = b.length;\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var aStart = 0;\n    var bStart = 0;\n    var i;\n    var j;\n    var aNode;\n    var bNode;\n    var nextNode;\n    var nextPos;\n    var node;\n    if (aLength === 0) {\n        if (bLength !== 0) {\n            mountArrayChildren(b, dom, lifecycle, context, isSVG);\n        }\n        return;\n    }\n    else if (bLength === 0) {\n        removeAllChildren(dom, a, lifecycle, isRecycling);\n        return;\n    }\n    var aStartNode = a[aStart];\n    var bStartNode = b[bStart];\n    var aEndNode = a[aEnd];\n    var bEndNode = b[bEnd];\n    if (bStartNode.dom) {\n        b[bStart] = bStartNode = cloneVNode(bStartNode);\n    }\n    if (bEndNode.dom) {\n        b[bEnd] = bEndNode = cloneVNode(bEndNode);\n    }\n    // Step 1\n    /* eslint no-constant-condition: 0 */\n    outer: while (true) {\n        // Sync nodes with the same key at the beginning.\n        while (aStartNode.key === bStartNode.key) {\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\n            aStart++;\n            bStart++;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aStartNode = a[aStart];\n            bStartNode = b[bStart];\n            if (bStartNode.dom) {\n                b[bStart] = bStartNode = cloneVNode(bStartNode);\n            }\n        }\n        // Sync nodes with the same key at the end.\n        while (aEndNode.key === bEndNode.key) {\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\n            aEnd--;\n            bEnd--;\n            if (aStart > aEnd || bStart > bEnd) {\n                break outer;\n            }\n            aEndNode = a[aEnd];\n            bEndNode = b[bEnd];\n            if (bEndNode.dom) {\n                b[bEnd] = bEndNode = cloneVNode(bEndNode);\n            }\n        }\n        // Move and sync nodes from right to left.\n        if (aEndNode.key === bStartNode.key) {\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\n            insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\n            aEnd--;\n            bStart++;\n            aEndNode = a[aEnd];\n            bStartNode = b[bStart];\n            if (bStartNode.dom) {\n                b[bStart] = bStartNode = cloneVNode(bStartNode);\n            }\n            continue;\n        }\n        // Move and sync nodes from left to right.\n        if (aStartNode.key === bEndNode.key) {\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\n            nextPos = bEnd + 1;\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n            insertOrAppend(dom, bEndNode.dom, nextNode);\n            aStart++;\n            bEnd--;\n            aStartNode = a[aStart];\n            bEndNode = b[bEnd];\n            if (bEndNode.dom) {\n                b[bEnd] = bEndNode = cloneVNode(bEndNode);\n            }\n            continue;\n        }\n        break;\n    }\n    if (aStart > aEnd) {\n        if (bStart <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n            while (bStart <= bEnd) {\n                node = b[bStart];\n                if (node.dom) {\n                    b[bStart] = node = cloneVNode(node);\n                }\n                bStart++;\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\n            }\n        }\n    }\n    else if (bStart > bEnd) {\n        while (aStart <= aEnd) {\n            unmount(a[aStart++], dom, lifecycle, false, isRecycling);\n        }\n    }\n    else {\n        aLength = aEnd - aStart + 1;\n        bLength = bEnd - bStart + 1;\n        var aNullable = a;\n        var sources = new Array(bLength);\n        // Mark all nodes as inserted.\n        for (i = 0; i < bLength; i++) {\n            sources[i] = -1;\n        }\n        var moved = false;\n        var pos = 0;\n        var patched = 0;\n        if ((bLength <= 4) || (aLength * bLength <= 16)) {\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLength) {\n                    for (j = bStart; j <= bEnd; j++) {\n                        bNode = b[j];\n                        if (aNode.key === bNode.key) {\n                            sources[j - bStart] = i;\n                            if (pos > j) {\n                                moved = true;\n                            }\n                            else {\n                                pos = j;\n                            }\n                            if (bNode.dom) {\n                                b[j] = bNode = cloneVNode(bNode);\n                            }\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\n                            patched++;\n                            aNullable[i] = null;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            var keyIndex = new Map();\n            for (i = bStart; i <= bEnd; i++) {\n                node = b[i];\n                keyIndex.set(node.key, i);\n            }\n            for (i = aStart; i <= aEnd; i++) {\n                aNode = a[i];\n                if (patched < bLength) {\n                    j = keyIndex.get(aNode.key);\n                    if (!isUndefined(j)) {\n                        bNode = b[j];\n                        sources[j - bStart] = i;\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.dom) {\n                            b[j] = bNode = cloneVNode(bNode);\n                        }\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\n                        patched++;\n                        aNullable[i] = null;\n                    }\n                }\n            }\n        }\n        if (aLength === a.length && patched === 0) {\n            removeAllChildren(dom, a, lifecycle, isRecycling);\n            while (bStart < bLength) {\n                node = b[bStart];\n                if (node.dom) {\n                    b[bStart] = node = cloneVNode(node);\n                }\n                bStart++;\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);\n            }\n        }\n        else {\n            i = aLength - patched;\n            while (i > 0) {\n                aNode = aNullable[aStart++];\n                if (!isNull(aNode)) {\n                    unmount(aNode, dom, lifecycle, true, isRecycling);\n                    i--;\n                }\n            }\n            if (moved) {\n                var seq = lis_algorithm(sources);\n                j = seq.length - 1;\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        if (node.dom) {\n                            b[pos] = node = cloneVNode(node);\n                        }\n                        nextPos = pos + 1;\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                        insertOrAppend(dom, mount(node, dom, lifecycle, context, isSVG), nextNode);\n                    }\n                    else {\n                        if (j < 0 || i !== seq[j]) {\n                            pos = i + bStart;\n                            node = b[pos];\n                            nextPos = pos + 1;\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                            insertOrAppend(dom, node.dom, nextNode);\n                        }\n                        else {\n                            j--;\n                        }\n                    }\n                }\n            }\n            else if (patched !== bLength) {\n                for (i = bLength - 1; i >= 0; i--) {\n                    if (sources[i] === -1) {\n                        pos = i + bStart;\n                        node = b[pos];\n                        if (node.dom) {\n                            b[pos] = node = cloneVNode(node);\n                        }\n                        nextPos = pos + 1;\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\n                    }\n                }\n            }\n        }\n    }\n}\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(a) {\n    var p = a.slice(0);\n    var result = [];\n    result.push(0);\n    var i;\n    var j;\n    var u;\n    var v;\n    var c;\n    for (i = 0; i < a.length; i++) {\n        if (a[i] === -1) {\n            continue;\n        }\n        j = result[result.length - 1];\n        if (a[j] < a[i]) {\n            p[i] = j;\n            result.push(i);\n            continue;\n        }\n        u = 0;\n        v = result.length - 1;\n        while (u < v) {\n            c = ((u + v) / 2) | 0;\n            if (a[result[c]] < a[i]) {\n                u = c + 1;\n            }\n            else {\n                v = c;\n            }\n        }\n        if (a[i] < a[result[u]]) {\n            if (u > 0) {\n                p[i] = result[u - 1];\n            }\n            result[u] = i;\n        }\n    }\n    u = result.length;\n    v = result[u - 1];\n    while (u-- > 0) {\n        result[u] = v;\n        v = p[v];\n    }\n    return result;\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, lifecycle) {\n    if (skipProps[prop]) {\n        return;\n    }\n    if (booleanProps[prop]) {\n        dom[prop] = nextValue ? true : false;\n    }\n    else if (strictProps[prop]) {\n        var value = isNullOrUndef(nextValue) ? '' : nextValue;\n        if (dom[prop] !== value) {\n            dom[prop] = value;\n        }\n    }\n    else if (lastValue !== nextValue) {\n        if (isAttrAnEvent(prop)) {\n            patchEvent(prop, lastValue, nextValue, dom, lifecycle);\n        }\n        else if (isNullOrUndef(nextValue)) {\n            dom.removeAttribute(prop);\n        }\n        else if (prop === 'className') {\n            if (isSVG) {\n                dom.setAttribute('class', nextValue);\n            }\n            else {\n                dom.className = nextValue;\n            }\n        }\n        else if (prop === 'style') {\n            patchStyle(lastValue, nextValue, dom);\n        }\n        else if (prop === 'dangerouslySetInnerHTML') {\n            var lastHtml = lastValue && lastValue.__html;\n            var nextHtml = nextValue && nextValue.__html;\n            if (lastHtml !== nextHtml) {\n                if (!isNullOrUndef(nextHtml)) {\n                    dom.innerHTML = nextHtml;\n                }\n            }\n        }\n        else if (prop !== 'childrenType' && prop !== 'ref' && prop !== 'key') {\n            var dehyphenProp;\n            if (dehyphenProps[prop]) {\n                dehyphenProp = dehyphenProps[prop];\n            }\n            else if (isSVG && prop.match(probablyKebabProps)) {\n                dehyphenProp = prop.replace(/([a-z])([A-Z]|1)/g, kebabize);\n                dehyphenProps[prop] = dehyphenProp;\n            }\n            else {\n                dehyphenProp = prop;\n            }\n            var ns = namespaces[prop];\n            if (ns) {\n                dom.setAttributeNS(ns, dehyphenProp, nextValue);\n            }\n            else {\n                dom.setAttribute(dehyphenProp, nextValue);\n            }\n        }\n    }\n}\nfunction patchEvents(lastEvents, nextEvents, dom, lifecycle) {\n    lastEvents = lastEvents || EMPTY_OBJ;\n    nextEvents = nextEvents || EMPTY_OBJ;\n    if (nextEvents !== EMPTY_OBJ) {\n        for (var name in nextEvents) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, lastEvents[name], nextEvents[name], dom, lifecycle);\n        }\n    }\n    if (lastEvents !== EMPTY_OBJ) {\n        for (var name$1 in lastEvents) {\n            // do not add a hasOwnProperty check here, it affects performance\n            if (isNullOrUndef(nextEvents[name$1])) {\n                patchEvent(name$1, lastEvents[name$1], null, dom, lifecycle);\n            }\n        }\n    }\n}\nfunction patchEvent(name, lastValue, nextValue, dom, lifecycle) {\n    if (lastValue !== nextValue) {\n        var nameLowerCase = name.toLowerCase();\n        var domEvent = dom[nameLowerCase];\n        // if the function is wrapped, that means it's been controlled by a wrapper\n        if (domEvent && domEvent.wrapped) {\n            return;\n        }\n        if (delegatedProps[name]) {\n            handleEvent(name, lastValue, nextValue, dom);\n        }\n        else {\n            if (lastValue !== nextValue) {\n                if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\n                    var linkEvent = nextValue.event;\n                    if (linkEvent && isFunction(linkEvent)) {\n                        if (!dom._data) {\n                            dom[nameLowerCase] = function (e) {\n                                linkEvent(e.currentTarget._data, e);\n                            };\n                        }\n                        dom._data = nextValue.data;\n                    }\n                    else {\n                        if (process.env.NODE_ENV !== 'production') {\n                            throwError((\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\"));\n                        }\n                        throwError();\n                    }\n                }\n                else {\n                    dom[nameLowerCase] = nextValue;\n                }\n            }\n        }\n    }\n}\nfunction patchProps(lastProps, nextProps, dom, lifecycle, context, isSVG) {\n    lastProps = lastProps || EMPTY_OBJ;\n    nextProps = nextProps || EMPTY_OBJ;\n    if (nextProps !== EMPTY_OBJ) {\n        for (var prop in nextProps) {\n            // do not add a hasOwnProperty check here, it affects performance\n            var nextValue = nextProps[prop];\n            var lastValue = lastProps[prop];\n            if (isNullOrUndef(nextValue)) {\n                removeProp(prop, nextValue, dom);\n            }\n            else {\n                patchProp(prop, lastValue, nextValue, dom, isSVG, lifecycle);\n            }\n        }\n    }\n    if (lastProps !== EMPTY_OBJ) {\n        for (var prop$1 in lastProps) {\n            // do not add a hasOwnProperty check here, it affects performance\n            if (isNullOrUndef(nextProps[prop$1])) {\n                removeProp(prop$1, lastProps[prop$1], dom);\n            }\n        }\n    }\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isString(nextAttrValue)) {\n        dom.style.cssText = nextAttrValue;\n        return;\n    }\n    for (var style in nextAttrValue) {\n        // do not add a hasOwnProperty check here, it affects performance\n        var value = nextAttrValue[style];\n        if (isNumber(value) && !isUnitlessNumber[style]) {\n            dom.style[style] = value + 'px';\n        }\n        else {\n            dom.style[style] = value;\n        }\n    }\n    if (!isNullOrUndef(lastAttrValue)) {\n        for (var style$1 in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style$1])) {\n                dom.style[style$1] = '';\n            }\n        }\n    }\n}\nfunction removeProp(prop, lastValue, dom) {\n    if (prop === 'className') {\n        dom.removeAttribute('class');\n    }\n    else if (prop === 'value') {\n        dom.value = '';\n    }\n    else if (prop === 'style') {\n        dom.removeAttribute('style');\n    }\n    else if (isAttrAnEvent(prop)) {\n        handleEvent(name, lastValue, null, dom);\n    }\n    else {\n        dom.removeAttribute(prop);\n    }\n}\n\nvar componentPools = new Map();\nvar elementPools = new Map();\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\n    var tag = vNode.type;\n    var key = vNode.key;\n    var pools = elementPools.get(tag);\n    if (!isUndefined(pools)) {\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\n        if (!isUndefined(pool)) {\n            var recycledVNode = pool.pop();\n            if (!isUndefined(recycledVNode)) {\n                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\n                return vNode.dom;\n            }\n        }\n    }\n    return null;\n}\nfunction poolElement(vNode) {\n    var tag = vNode.type;\n    var key = vNode.key;\n    var pools = elementPools.get(tag);\n    if (isUndefined(pools)) {\n        pools = {\n            nonKeyed: [],\n            keyed: new Map()\n        };\n        elementPools.set(tag, pools);\n    }\n    if (isNull(key)) {\n        pools.nonKeyed.push(vNode);\n    }\n    else {\n        var pool = pools.keyed.get(key);\n        if (isUndefined(pool)) {\n            pool = [];\n            pools.keyed.set(key, pool);\n        }\n        pool.push(vNode);\n    }\n}\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\n    var type = vNode.type;\n    var key = vNode.key;\n    var pools = componentPools.get(type);\n    if (!isUndefined(pools)) {\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\n        if (!isUndefined(pool)) {\n            var recycledVNode = pool.pop();\n            if (!isUndefined(recycledVNode)) {\n                var flags = vNode.flags;\n                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, flags & 4 /* ComponentClass */, true);\n                if (!failed) {\n                    return vNode.dom;\n                }\n            }\n        }\n    }\n    return null;\n}\nfunction poolComponent(vNode) {\n    var type = vNode.type;\n    var key = vNode.key;\n    var hooks = vNode.ref;\n    var nonRecycleHooks = hooks && (hooks.onComponentWillMount ||\n        hooks.onComponentWillUnmount ||\n        hooks.onComponentDidMount ||\n        hooks.onComponentWillUpdate ||\n        hooks.onComponentDidUpdate);\n    if (nonRecycleHooks) {\n        return;\n    }\n    var pools = componentPools.get(type);\n    if (isUndefined(pools)) {\n        pools = {\n            nonKeyed: [],\n            keyed: new Map()\n        };\n        componentPools.set(type, pools);\n    }\n    if (isNull(key)) {\n        pools.nonKeyed.push(vNode);\n    }\n    else {\n        var pool = pools.keyed.get(key);\n        if (isUndefined(pool)) {\n            pool = [];\n            pools.keyed.set(key, pool);\n        }\n        pool.push(vNode);\n    }\n}\n\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\n    var flags = vNode.flags;\n    if (flags & 3970 /* Element */) {\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\n    }\n    else if (flags & 28 /* Component */) {\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, flags & 4 /* ComponentClass */);\n    }\n    else if (flags & 4096 /* Void */) {\n        return mountVoid(vNode, parentDom);\n    }\n    else if (flags & 1 /* Text */) {\n        return mountText(vNode, parentDom);\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof vNode === 'object') {\n                throwError((\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + (JSON.stringify(vNode)) + \"\\\".\"));\n            }\n            else {\n                throwError((\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\n            }\n        }\n        throwError();\n    }\n}\nfunction mountText(vNode, parentDom) {\n    var dom = document.createTextNode(vNode.children);\n    vNode.dom = dom;\n    if (parentDom) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountVoid(vNode, parentDom) {\n    var dom = document.createTextNode('');\n    vNode.dom = dom;\n    if (parentDom) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\n    if (options.recyclingEnabled) {\n        var dom$1 = recycleElement(vNode, lifecycle, context, isSVG);\n        if (!isNull(dom$1)) {\n            if (!isNull(parentDom)) {\n                appendChild(parentDom, dom$1);\n            }\n            return dom$1;\n        }\n    }\n    var tag = vNode.type;\n    var flags = vNode.flags;\n    if (isSVG || (flags & 128 /* SvgElement */)) {\n        isSVG = true;\n    }\n    var dom = documentCreateElement(tag, isSVG);\n    var children = vNode.children;\n    var props = vNode.props;\n    var events = vNode.events;\n    var ref = vNode.ref;\n    vNode.dom = dom;\n    if (!isNull(children)) {\n        if (isStringOrNumber(children)) {\n            setTextContent(dom, children);\n        }\n        else if (isArray(children)) {\n            mountArrayChildren(children, dom, lifecycle, context, isSVG);\n        }\n        else if (isVNode(children)) {\n            mount(children, dom, lifecycle, context, isSVG);\n        }\n    }\n    if (!(flags & 2 /* HtmlElement */)) {\n        processElement(flags, vNode, dom);\n    }\n    if (!isNull(props)) {\n        for (var prop in props) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchProp(prop, null, props[prop], dom, isSVG, lifecycle);\n        }\n    }\n    if (!isNull(events)) {\n        for (var name in events) {\n            // do not add a hasOwnProperty check here, it affects performance\n            patchEvent(name, null, events[name], dom, lifecycle);\n        }\n    }\n    if (!isNull(ref)) {\n        mountRef(dom, ref, lifecycle);\n    }\n    if (!isNull(parentDom)) {\n        appendChild(parentDom, dom);\n    }\n    return dom;\n}\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (!isInvalid(child)) {\n            if (child.dom) {\n                children[i] = child = cloneVNode(child);\n            }\n            mount(children[i], dom, lifecycle, context, isSVG);\n        }\n    }\n}\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\n    if (options.recyclingEnabled) {\n        var dom$1 = recycleComponent(vNode, lifecycle, context, isSVG);\n        if (!isNull(dom$1)) {\n            if (!isNull(parentDom)) {\n                appendChild(parentDom, dom$1);\n            }\n            return dom$1;\n        }\n    }\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var defaultProps = type.defaultProps;\n    var ref = vNode.ref;\n    var dom;\n    if (!isUndefined(defaultProps)) {\n        copyPropsTo(defaultProps, props);\n        vNode.props = props;\n    }\n    if (isClass) {\n        var instance = createClassComponentInstance(vNode, type, props, context, isSVG);\n        // If instance does not have componentWillUnmount specified we can enable fastUnmount\n        var input = instance._lastInput;\n        var prevFastUnmount = lifecycle.fastUnmount;\n        // we store the fastUnmount value, but we set it back to true on the lifecycle\n        // we do this so we can determine if the component render has a fastUnmount or not\n        lifecycle.fastUnmount = true;\n        instance._vNode = vNode;\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\n        // we now create a lifecycle for this component and store the fastUnmount value\n        var subLifecycle = instance._lifecycle = new Lifecycle();\n        // children lifecycle can fastUnmount if itself does need unmount callback and within its cycle there was none\n        subLifecycle.fastUnmount = isUndefined(instance.componentWillUnmount) && lifecycle.fastUnmount;\n        // higher lifecycle can fastUnmount only if previously it was able to and this children doesnt have any\n        lifecycle.fastUnmount = prevFastUnmount && subLifecycle.fastUnmount;\n        if (!isNull(parentDom)) {\n            appendChild(parentDom, dom);\n        }\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, dom);\n        vNode.children = instance;\n    }\n    else {\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\n        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);\n        vNode.children = input$1;\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n        if (!isNull(parentDom)) {\n            appendChild(parentDom, dom);\n        }\n    }\n    return dom;\n}\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\n    if (ref) {\n        if (isFunction(ref)) {\n            ref(instance);\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                if (isStringOrNumber(ref)) {\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n                }\n                else if (isObject(ref) && (vNode.flags & 4 /* ComponentClass */)) {\n                    throwError('functional component lifecycle events are not supported on ES2015 class components.');\n                }\n                else {\n                    throwError((\"a bad value for \\\"ref\\\" was used on component: \\\"\" + (JSON.stringify(ref)) + \"\\\"\"));\n                }\n            }\n            throwError();\n        }\n    }\n    var cDM = instance.componentDidMount;\n    var afterMount = options.afterMount;\n    if (!isUndefined(cDM) || !isNull(afterMount)) {\n        lifecycle.addListener(function () {\n            afterMount && afterMount(vNode);\n            cDM && instance.componentDidMount();\n        });\n    }\n}\nfunction mountFunctionalComponentCallbacks(ref, dom, lifecycle) {\n    if (ref) {\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\n            ref.onComponentWillMount();\n        }\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\n            lifecycle.addListener(function () { return ref.onComponentDidMount(dom); });\n        }\n        if (!isNullOrUndef(ref.onComponentWillUnmount)) {\n            lifecycle.fastUnmount = false;\n        }\n    }\n}\nfunction mountRef(dom, value, lifecycle) {\n    if (isFunction(value)) {\n        lifecycle.fastUnmount = false;\n        lifecycle.addListener(function () { return value(dom); });\n    }\n    else {\n        if (isInvalid(value)) {\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\n        }\n        throwError();\n    }\n}\n\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG) {\n    if (isUndefined(context)) {\n        context = {};\n    }\n    var instance = new Component(props, context);\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    instance._patch = patch;\n    if (options.findDOMNodeEnabled) {\n        instance._componentToDOMNodeMap = componentToDOMNodeMap;\n    }\n    instance._unmounted = false;\n    instance._pendingSetState = true;\n    instance._isSVG = isSVG;\n    instance.componentWillMount();\n    var childContext = instance.getChildContext();\n    if (!isNullOrUndef(childContext)) {\n        instance._childContext = Object.assign({}, context, childContext);\n    }\n    else {\n        instance._childContext = context;\n    }\n    options.beforeRender && options.beforeRender(instance);\n    var input = instance.render(props, instance.state, context);\n    options.afterRender && options.afterRender(instance);\n    if (isArray(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        throwError();\n    }\n    else if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input);\n    }\n    else {\n        if (input.dom) {\n            input = cloneVNode(input);\n        }\n        if (input.flags & 28 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = vNode;\n        }\n    }\n    instance._pendingSetState = false;\n    instance._lastInput = input;\n    return instance;\n}\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\n}\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\n    var shallowUnmount = false;\n    // we cannot cache nodeType here as vNode might be re-assigned below\n    if (vNode.flags & 28 /* Component */) {\n        // if we are accessing a stateful or stateless component, we want to access their last rendered input\n        // accessing their DOM node is not useful to us here\n        unmount(vNode, null, lifecycle, false, isRecycling);\n        vNode = vNode.children._lastInput || vNode.children;\n        shallowUnmount = true;\n    }\n    replaceChild(parentDom, dom, vNode.dom);\n    unmount(vNode, null, lifecycle, false, isRecycling);\n}\nfunction createFunctionalComponentInput(vNode, component, props, context) {\n    var input = component(props, context);\n    if (isArray(input)) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.');\n        }\n        throwError();\n    }\n    else if (isInvalid(input)) {\n        input = createVoidVNode();\n    }\n    else if (isStringOrNumber(input)) {\n        input = createTextVNode(input);\n    }\n    else {\n        if (input.dom) {\n            input = cloneVNode(input);\n        }\n        if (input.flags & 28 /* Component */) {\n            // if we have an input that is also a component, we run into a tricky situation\n            // where the root vNode needs to always have the correct DOM entry\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\n            // we can optimise this in the future, but this gets us out of a lot of issues\n            input.parentVNode = vNode;\n        }\n    }\n    return input;\n}\nfunction setTextContent(dom, text) {\n    if (text !== '') {\n        dom.textContent = text;\n    }\n    else {\n        dom.appendChild(document.createTextNode(''));\n    }\n}\nfunction updateTextContent(dom, text) {\n    dom.firstChild.nodeValue = text;\n}\nfunction appendChild(parentDom, dom) {\n    parentDom.appendChild(dom);\n}\nfunction insertOrAppend(parentDom, newNode, nextNode) {\n    if (isNullOrUndef(nextNode)) {\n        appendChild(parentDom, newNode);\n    }\n    else {\n        parentDom.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG === true) {\n        return document.createElementNS(svgNS, tag);\n    }\n    else {\n        return document.createElement(tag);\n    }\n}\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\n    unmount(lastNode, null, lifecycle, false, isRecycling);\n    var dom = mount(nextNode, null, lifecycle, context, isSVG);\n    nextNode.dom = dom;\n    replaceChild(parentDom, dom, lastNode.dom);\n}\nfunction replaceChild(parentDom, nextDom, lastDom) {\n    if (!parentDom) {\n        parentDom = lastDom.parentNode;\n    }\n    parentDom.replaceChild(nextDom, lastDom);\n}\nfunction removeChild(parentDom, dom) {\n    parentDom.removeChild(dom);\n}\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\n    dom.textContent = '';\n    if (!lifecycle.fastUnmount || (lifecycle.fastUnmount && options.recyclingEnabled && !isRecycling)) {\n        removeChildren(null, children, lifecycle, isRecycling);\n    }\n}\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\n    for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (!isInvalid(child)) {\n            unmount(child, dom, lifecycle, true, isRecycling);\n        }\n    }\n}\nfunction isKeyed(lastChildren, nextChildren) {\n    return nextChildren.length && !isNullOrUndef(nextChildren[0]) && !isNullOrUndef(nextChildren[0].key)\n        && lastChildren.length && !isNullOrUndef(lastChildren[0]) && !isNullOrUndef(lastChildren[0].key);\n}\n\nfunction normalizeChildNodes(parentDom) {\n    var dom = parentDom.firstChild;\n    while (dom) {\n        if (dom.nodeType === 8) {\n            if (dom.data === '!') {\n                var placeholder = document.createTextNode('');\n                parentDom.replaceChild(placeholder, dom);\n                dom = dom.nextSibling;\n            }\n            else {\n                var lastDom = dom.previousSibling;\n                parentDom.removeChild(dom);\n                dom = lastDom || parentDom.firstChild;\n            }\n        }\n        else {\n            dom = dom.nextSibling;\n        }\n    }\n}\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\n    var type = vNode.type;\n    var props = vNode.props || EMPTY_OBJ;\n    var ref = vNode.ref;\n    vNode.dom = dom;\n    if (isClass) {\n        var _isSVG = dom.namespaceURI === svgNS;\n        var defaultProps = type.defaultProps;\n        if (!isUndefined(defaultProps)) {\n            copyPropsTo(defaultProps, props);\n            vNode.props = props;\n        }\n        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG);\n        // If instance does not have componentWillUnmount specified we can enable fastUnmount\n        var prevFastUnmount = lifecycle.fastUnmount;\n        var input = instance._lastInput;\n        // we store the fastUnmount value, but we set it back to true on the lifecycle\n        // we do this so we can determine if the component render has a fastUnmount or not\n        lifecycle.fastUnmount = true;\n        instance._vComponent = vNode;\n        instance._vNode = vNode;\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\n        // we now create a lifecycle for this component and store the fastUnmount value\n        var subLifecycle = instance._lifecycle = new Lifecycle();\n        // children lifecycle can fastUnmount if itself does need unmount callback and within its cycle there was none\n        subLifecycle.fastUnmount = isUndefined(instance.componentWillUnmount) && lifecycle.fastUnmount;\n        // higher lifecycle can fastUnmount only if previously it was able to and this children doesnt have any\n        lifecycle.fastUnmount = prevFastUnmount && subLifecycle.fastUnmount;\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\n        options.findDOMNodeEnabled && componentToDOMNodeMap.set(instance, dom);\n        vNode.children = instance;\n    }\n    else {\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\n        hydrate(input$1, dom, lifecycle, context, isSVG);\n        vNode.children = input$1;\n        vNode.dom = input$1.dom;\n        mountFunctionalComponentCallbacks(ref, dom, lifecycle);\n    }\n    return dom;\n}\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\n    var tag = vNode.type;\n    var children = vNode.children;\n    var props = vNode.props;\n    var events = vNode.events;\n    var flags = vNode.flags;\n    var ref = vNode.ref;\n    if (isSVG || (flags & 128 /* SvgElement */)) {\n        isSVG = true;\n    }\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== tag) {\n        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);\n        vNode.dom = newDom;\n        replaceChild(dom.parentNode, newDom, dom);\n        return newDom;\n    }\n    vNode.dom = dom;\n    if (children) {\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\n    }\n    if (!(flags & 2 /* HtmlElement */)) {\n        processElement(flags, vNode, dom);\n    }\n    if (props) {\n        for (var prop in props) {\n            patchProp(prop, null, props[prop], dom, isSVG, lifecycle);\n        }\n    }\n    if (events) {\n        for (var name in events) {\n            patchEvent(name, null, events[name], dom, lifecycle);\n        }\n    }\n    if (ref) {\n        mountRef(dom, ref, lifecycle);\n    }\n    return dom;\n}\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\n    normalizeChildNodes(parentDom);\n    var dom = parentDom.firstChild;\n    if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (isObject(child) && !isNull(child)) {\n                if (dom) {\n                    dom = hydrate(child, dom, lifecycle, context, isSVG);\n                    dom = dom.nextSibling;\n                }\n                else {\n                    mount(child, parentDom, lifecycle, context, isSVG);\n                }\n            }\n        }\n    }\n    else if (isStringOrNumber(children)) {\n        if (dom && dom.nodeType === 3) {\n            if (dom.nodeValue !== children) {\n                dom.nodeValue = children;\n            }\n        }\n        else if (children) {\n            parentDom.textContent = children;\n        }\n        dom = dom.nextSibling;\n    }\n    else if (isObject(children)) {\n        hydrate(children, dom, lifecycle, context, isSVG);\n        dom = dom.nextSibling;\n    }\n    // clear any other DOM nodes, there should be only a single entry for the root\n    while (dom) {\n        parentDom.removeChild(dom);\n        dom = dom.nextSibling;\n    }\n}\nfunction hydrateText(vNode, dom) {\n    if (dom.nodeType !== 3) {\n        var newDom = mountText(vNode, null);\n        vNode.dom = newDom;\n        replaceChild(dom.parentNode, newDom, dom);\n        return newDom;\n    }\n    var text = vNode.children;\n    if (dom.nodeValue !== text) {\n        dom.nodeValue = text;\n    }\n    vNode.dom = dom;\n    return dom;\n}\nfunction hydrateVoid(vNode, dom) {\n    vNode.dom = dom;\n}\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (isInvalid(dom)) {\n            throwError(\"failed to hydrate. The server-side render doesn't match client side.\");\n        }\n    }\n    var flags = vNode.flags;\n    if (flags & 28 /* Component */) {\n        return hydrateComponent(vNode, dom, lifecycle, context, isSVG, flags & 4 /* ComponentClass */);\n    }\n    else if (flags & 3970 /* Element */) {\n        return hydrateElement(vNode, dom, lifecycle, context, isSVG);\n    }\n    else if (flags & 1 /* Text */) {\n        return hydrateText(vNode, dom);\n    }\n    else if (flags & 4096 /* Void */) {\n        return hydrateVoid(vNode, dom);\n    }\n    else {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError((\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\n        }\n        throwError();\n    }\n}\nfunction hydrateRoot(input, parentDom, lifecycle) {\n    var dom = parentDom && parentDom.firstChild;\n    if (dom) {\n        hydrate(input, dom, lifecycle, {}, false);\n        dom = parentDom.firstChild;\n        // clear any other DOM nodes, there should be only a single entry for the root\n        while (dom = dom.nextSibling) {\n            parentDom.removeChild(dom);\n        }\n        return true;\n    }\n    return false;\n}\n\n// rather than use a Map, like we did before, we can use an array here\n// given there shouldn't be THAT many roots on the page, the difference\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\nvar roots = [];\nvar componentToDOMNodeMap = new Map();\noptions.roots = roots;\nfunction findDOMNode(ref) {\n    if (!options.findDOMNodeEnabled) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!');\n        }\n        throwError();\n    }\n    var dom = ref && ref.nodeType ? ref : null;\n    return componentToDOMNodeMap.get(ref) || dom;\n}\nfunction getRoot(dom) {\n    for (var i = 0; i < roots.length; i++) {\n        var root = roots[i];\n        if (root.dom === dom) {\n            return root;\n        }\n    }\n    return null;\n}\n\nfunction setRoot(dom, input, lifecycle) {\n    var root = {\n        dom: dom,\n        input: input,\n        lifecycle: lifecycle\n    };\n    roots.push(root);\n    return root;\n}\nfunction removeRoot(root) {\n    for (var i = 0; i < roots.length; i++) {\n        if (roots[i] === root) {\n            roots.splice(i, 1);\n            return;\n        }\n    }\n}\nvar documentBody = isBrowser ? document.body : null;\nfunction render(input, parentDom) {\n    if (documentBody === parentDom) {\n        if (process.env.NODE_ENV !== 'production') {\n            throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\n        }\n        throwError();\n    }\n    if (input === NO_OP) {\n        return;\n    }\n    var root = getRoot(parentDom);\n    if (isNull(root)) {\n        var lifecycle = new Lifecycle();\n        if (!isInvalid(input)) {\n            if (input.dom) {\n                input = cloneVNode(input);\n            }\n            if (!hydrateRoot(input, parentDom, lifecycle)) {\n                mount(input, parentDom, lifecycle, {}, false);\n            }\n            root = setRoot(parentDom, input, lifecycle);\n            lifecycle.trigger();\n        }\n    }\n    else {\n        var lifecycle$1 = root.lifecycle;\n        lifecycle$1.listeners = [];\n        if (isNullOrUndef(input)) {\n            unmount(root.input, parentDom, lifecycle$1, false, false);\n            removeRoot(root);\n        }\n        else {\n            if (input.dom) {\n                input = cloneVNode(input);\n            }\n            patch(root.input, input, parentDom, lifecycle$1, {}, false, false);\n        }\n        lifecycle$1.trigger();\n        root.input = input;\n    }\n    if (root) {\n        var rootInput = root.input;\n        if (rootInput && (rootInput.flags & 28 /* Component */)) {\n            return rootInput.children;\n        }\n    }\n}\nfunction createRenderer(_parentDom) {\n    var parentDom = _parentDom || null;\n    return function renderer(lastInput, nextInput) {\n        if (!parentDom) {\n            parentDom = lastInput;\n        }\n        render(nextInput, parentDom);\n    };\n}\n\nfunction linkEvent(data, event) {\n    return { data: data, event: event };\n}\n\nif (process.env.NODE_ENV !== 'production') {\n\tObject.freeze(EMPTY_OBJ);\n\tvar testFunc = function testFn() {};\n\twarning(\n\t\t(testFunc.name || testFunc.toString()).indexOf('testFn') !== -1,\n\t\t'It looks like you\\'re using a minified copy of the development build ' +\n\t\t'of Inferno. When deploying Inferno apps to production, make sure to use ' +\n\t\t'the production build which skips development warnings and is faster. ' +\n\t\t'See http://infernojs.org for more details.'\n\t);\n}\n\n// we duplicate it so it plays nicely with different module loading systems\nvar index = {\n\tlinkEvent: linkEvent,\n\t// core shapes\n\tcreateVNode: createVNode,\n\n\t// cloning\n\tcloneVNode: cloneVNode,\n\n\t// used to shared common items between Inferno libs\n\tNO_OP: NO_OP,\n\tEMPTY_OBJ: EMPTY_OBJ,\n\n\t// DOM\n\trender: render,\n\tfindDOMNode: findDOMNode,\n\tcreateRenderer: createRenderer,\n\toptions: options\n};\n\nexports['default'] = index;\nexports.linkEvent = linkEvent;\nexports.createVNode = createVNode;\nexports.cloneVNode = cloneVNode;\nexports.NO_OP = NO_OP;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.render = render;\nexports.findDOMNode = findDOMNode;\nexports.createRenderer = createRenderer;\nexports.options = options;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/inferno/dist/inferno.node.js\n// module id = 4\n// module chunks = 0","import Inferno from 'inferno'\nimport createElement from 'inferno-create-element'\nimport acomponent from './acomponent'\n\nfunction runapp() {\n  Inferno.render(\n    acomponent(), document.getElementById('inferno')\n  )\n}\n\n// this is only relevant when using `hot` mode with webpack\n// special thanks to Eric Clemmons: https://github.com/ericclemmons/webpack-hot-server-example\nconst reloading = document.readyState === 'complete'\nif (module.hot) {\n  module.hot.accept(function (err) {\n    console.log('❌  HMR Error:', err)\n  })\n  if (reloading) {\n    console.log('🔁  HMR Reloading.')\n    runapp()\n  } else {\n    console.info('✅  HMR Enabled.')\n    runapp()\n  }\n} else {\n  console.info('❌  HMR Not Supported.')\n  runapp()\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./myapp.js"],"sourceRoot":""}